#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "write_in_files_handlers.h"

#define  L_TOTAL      240     /* Total size of speech buffer.               */
#define  L_WINDOW     240     /* Window size in LP analysis.                */
#define  L_NEXT       40      /* Lookahead in LP analysis.                  */
#define  L_FRAME      80      /* Frame size.                                */
#define  L_SUBFR      40      /* Subframe size.                             */
#define  M            10      /* Order of LP filter.                        */
#define  MP1          (M+1)   /* Order of LP filter + 1                     */
#define  PIT_MIN      20      /* Minimum pitch lag.                         */
#define  PIT_MAX      143     /* Maximum pitch lag.                         */
#define  L_INTERPOL   (10+1)  /* Length of filter for interpolation.        */
#define  GAMMA1       24576   /* Bandwitdh factor = 0.75   in Q15           */

#define  PRM_SIZE     11      /* Size of vector of analysis parameters.     */
#define  SERIAL_SIZE  (80+2)  /* bfi+ number of speech bits                 */

#define SHARPMAX  13017   /* Maximum value of pitch sharpening     0.8  Q14 */
#define SHARPMIN  3277    /* Minimum value of pitch sharpening     0.2  Q14 */

#define UP_SAMP         3
#define L_INTER10       10
#define FIR_SIZE_SYN    (UP_SAMP*L_INTER10+1)

#define DIM_RR  616 /* size of correlation matrix                            */
#define NB_POS  8   /* Number of positions for each pulse                    */
#define STEP    5   /* Step betweem position of the same pulse.              */
#define MSIZE   64  /* Size of vectors for cross-correlation between 2 pulses*/

/* The following constants are Q15 fractions.
   These fractions is used to keep maximum precision on "alp" sum */

#define _1_2    (short)(16384)
#define _1_4    (short)( 8192)
#define _1_8    (short)( 4096)
#define _1_16   (short)( 2048)

#define   NC            5      /*  NC = M/2 */
#define   MA_NP         4      /* MA prediction order for LSP */
#define   MODE          2      /* number of modes for MA prediction */
#define   NC0_B         7      /* number of first stage bits */
#define   NC1_B         5      /* number of second stage bits */
#define   NC0           (1<<NC0_B)
#define   NC1           (1<<NC1_B)

#define   L_LIMIT          40   /* Q13:0.005 */
#define   M_LIMIT       25681   /* Q13:3.135 */

#define   GAP1          10     /* Q13 */
#define   GAP2          5      /* Q13 */
#define   GAP3          321    /* Q13 */
#define GRID_POINTS     50

#define PI04      ((short)1029)        /* Q13  pi*0.04 */
#define PI92      ((short)23677)       /* Q13  pi*0.92 */
#define CONST10   ((short)10*(1<<11))  /* Q11  10.0 */
#define CONST12   ((short)19661)       /* Q14  1.2 */

#define NCODE1_B  3                /* number of Codebook-bit */
#define NCODE2_B  4                /* number of Codebook-bit */
#define NCODE1    (1<<NCODE1_B)    /* Codebook 1 size */
#define NCODE2    (1<<NCODE2_B)    /* Codebook 2 size */
#define NCAN1     4                /* Pre-selecting order for #1 */
#define NCAN2     8                /* Pre-selecting order for #2 */
#define INV_COEF  -17103           /* Q19 */

#define BIT_0     (short)0x007f /* definition of zero-bit in bit-stream      */
#define BIT_1     (short)0x0081 /* definition of one-bit in bit-stream       */
#define SYNC_WORD (short)0x6b21 /* definition of frame erasure short          */
#define SIZE_WORD (short)80     /* number of speech bits                     */


/*-----------------------------------*
 * Post-filter functions.            *
 *-----------------------------------*/

#define L_H 22     /* size of truncated impulse response of A(z/g1)/A(z/g2) */

#define GAMMAP      16384   /* 0.5               (Q15) */
#define INV_GAMMAP  21845   /* 1/(1+GAMMAP)      (Q15) */
#define GAMMAP_2    10923   /* GAMMAP/(1+GAMMAP) (Q15) */

#define  GAMMA2_PST 18022 /* Formant postfilt factor (numerator)   0.55 Q15 */
#define  GAMMA1_PST 22938 /* Formant postfilt factor (denominator) 0.70 Q15 */

#define  MU       26214   /* Factor for tilt compensation filter   0.8  Q15 */
#define  AGC_FAC  29491   /* Factor for automatic gain control     0.9  Q15 */
#define  AGC_FAC1 (short)(32767 - AGC_FAC)    /* 1-AGC_FAC in Q15          */
#define GPCLIP      15564      /* Maximum pitch gain if taming is needed Q14*/
#define GPCLIP2     481        /* Maximum pitch gain if taming is needed Q9 */
#define GP0999      16383      /* Maximum pitch gain if taming is needed    */
#define L_THRESH_ERR 983040000L /* Error threshold taming 16384. * 60000.   */

#define MAX_32 (int)0x7fffffffL
#define MIN_32 (int)0x80000000L
#define MAX_16 (short)0x7fff
#define MIN_16 (short)0x8000

/* This file contains all the tables used by the G.729A codec */
/* Hamming_cos window for LPC analysis.           */
/*   Create with function ham_cos(window,200,40)  */

short hamwindow[L_WINDOW] = {
  2621,  2623,  2629,  2638,  2651,  2668,  2689,  2713,  2741,  2772,
  2808,  2847,  2890,  2936,  2986,  3040,  3097,  3158,  3223,  3291,
  3363,  3438,  3517,  3599,  3685,  3774,  3867,  3963,  4063,  4166,
  4272,  4382,  4495,  4611,  4731,  4853,  4979,  5108,  5240,  5376,
  5514,  5655,  5800,  5947,  6097,  6250,  6406,  6565,  6726,  6890,
  7057,  7227,  7399,  7573,  7750,  7930,  8112,  8296,  8483,  8672,
  8863,  9057,  9252,  9450,  9650,  9852, 10055, 10261, 10468, 10677,
 10888, 11101, 11315, 11531, 11748, 11967, 12187, 12409, 12632, 12856,
 13082, 13308, 13536, 13764, 13994, 14225, 14456, 14688, 14921, 15155,
 15389, 15624, 15859, 16095, 16331, 16568, 16805, 17042, 17279, 17516,
 17754, 17991, 18228, 18465, 18702, 18939, 19175, 19411, 19647, 19882,
 20117, 20350, 20584, 20816, 21048, 21279, 21509, 21738, 21967, 22194,
 22420, 22644, 22868, 23090, 23311, 23531, 23749, 23965, 24181, 24394,
 24606, 24816, 25024, 25231, 25435, 25638, 25839, 26037, 26234, 26428,
 26621, 26811, 26999, 27184, 27368, 27548, 27727, 27903, 28076, 28247,
 28415, 28581, 28743, 28903, 29061, 29215, 29367, 29515, 29661, 29804,
 29944, 30081, 30214, 30345, 30472, 30597, 30718, 30836, 30950, 31062,
 31170, 31274, 31376, 31474, 31568, 31659, 31747, 31831, 31911, 31988,
 32062, 32132, 32198, 32261, 32320, 32376, 32428, 32476, 32521, 32561,
 32599, 32632, 32662, 32688, 32711, 32729, 32744, 32755, 32763, 32767,
 32767, 32741, 32665, 32537, 32359, 32129, 31850, 31521, 31143, 30716,
 30242, 29720, 29151, 28538, 27879, 27177, 26433, 25647, 24821, 23957,
 23055, 22117, 21145, 20139, 19102, 18036, 16941, 15820, 14674, 13505,
 12315, 11106,  9879,  8637,  7381,  6114,  4838,  3554,  2264,   971};


/*-----------------------------------------------------*
 | Table of lag_window for autocorrelation.            |
 | noise floor = 1.0001   = (0.9999  on r[1] ..r[10])  |
 | Bandwidth expansion = 60 Hz                         |
 |                                                     |
 | Special double precision format. See "oper_32b.c"   |
 |                                                     |
 | lag_wind[0] =  1.00000000    (not stored)           |
 | lag_wind[1] =  0.99879038                           |
 | lag_wind[2] =  0.99546897                           |
 | lag_wind[3] =  0.98995781                           |
 | lag_wind[4] =  0.98229337                           |
 | lag_wind[5] =  0.97252619                           |
 | lag_wind[6] =  0.96072036                           |
 | lag_wind[7] =  0.94695264                           |
 | lag_wind[8] =  0.93131179                           |
 | lag_wind[9] =  0.91389757                           |
 | lag_wind[10]=  0.89481968                           |
 -----------------------------------------------------*/

short lag_h[M] = {    32728,    32619,    32438,    32187,    31867,    31480,    31029,    30517,    29946,    29321};
short lag_l[M] = {    11904,    17280,    30720,    25856,    24192,    28992,    24384,     7360,    19520,    14784};
/* table of cos(x) in Q15 */

short table[65] = {
  32767,  32729,  32610,  32413,  32138,  31786,  31357,  30853,
  30274,  29622,  28899,  28106,  27246,  26320,  25330,  24279,
  23170,  22006,  20788,  19520,  18205,  16846,  15447,  14010,
  12540,  11039,   9512,   7962,   6393,   4808,   3212,   1608,
      0,  -1608,  -3212,  -4808,  -6393,  -7962,  -9512, -11039,
 -12540, -14010, -15447, -16846, -18205, -19520, -20788, -22006,
 -23170, -24279, -25330, -26320, -27246, -28106, -28899, -29622,
 -30274, -30853, -31357, -31786, -32138, -32413, -32610, -32729,
 -32768L };

/* slope in Q12 used to compute y = acos(x) */

short slope[64] = {
 -26887,  -8812,  -5323,  -3813,  -2979,  -2444,  -2081,  -1811,
  -1608,  -1450,  -1322,  -1219,  -1132,  -1059,   -998,   -946,
   -901,   -861,   -827,   -797,   -772,   -750,   -730,   -713,
   -699,   -687,   -677,   -668,   -662,   -657,   -654,   -652,
   -652,   -654,   -657,   -662,   -668,   -677,   -687,   -699,
   -713,   -730,   -750,   -772,   -797,   -827,   -861,   -901,
   -946,   -998,  -1059,  -1132,  -1219,  -1322,  -1450,  -1608,
  -1811,  -2081,  -2444,  -2979,  -3813,  -5323,  -8812, -26887};


/*-----------------------------------------------------*
 | Tables for function Lsf_lsp() and Lsp_lsf()         |
  -----------------------------------------------------*/

/* table of cos(x) in Q15 */

short table2[64] = {
  32767,  32729,  32610,  32413,  32138,  31786,  31357,  30853,
  30274,  29622,  28899,  28106,  27246,  26320,  25330,  24279,
  23170,  22006,  20788,  19520,  18205,  16846,  15447,  14010,
  12540,  11039,   9512,   7962,   6393,   4808,   3212,   1608,
      0,  -1608,  -3212,  -4808,  -6393,  -7962,  -9512, -11039,
 -12540, -14010, -15447, -16846, -18205, -19520, -20788, -22006,
 -23170, -24279, -25330, -26320, -27246, -28106, -28899, -29622,
 -30274, -30853, -31357, -31786, -32138, -32413, -32610, -32729 };

/* slope in Q19 used to compute y = cos(x) */

short slope_cos[64] = {
   -632,  -1893,  -3150,  -4399,  -5638,  -6863,  -8072,  -9261,
 -10428, -11570, -12684, -13767, -14817, -15832, -16808, -17744,
 -18637, -19486, -20287, -21039, -21741, -22390, -22986, -23526,
 -24009, -24435, -24801, -25108, -25354, -25540, -25664, -25726,
 -25726, -25664, -25540, -25354, -25108, -24801, -24435, -24009,
 -23526, -22986, -22390, -21741, -21039, -20287, -19486, -18637,
 -17744, -16808, -15832, -14817, -13767, -12684, -11570, -10428,
  -9261,  -8072,  -6863,  -5638,  -4399,  -3150,  -1893,   -632 };

/* slope in Q12 used to compute y = acos(x) */

short slope_acos[64] = {
 -26887,  -8812,  -5323,  -3813,  -2979,  -2444,  -2081,  -1811,
  -1608,  -1450,  -1322,  -1219,  -1132,  -1059,   -998,   -946,
   -901,   -861,   -827,   -797,   -772,   -750,   -730,   -713,
   -699,   -687,   -677,   -668,   -662,   -657,   -654,   -652,
   -652,   -654,   -657,   -662,   -668,   -677,   -687,   -699,
   -713,   -730,   -750,   -772,   -797,   -827,   -861,   -901,
   -946,   -998,  -1059,  -1132,  -1219,  -1322,  -1450,  -1608,
  -1811,  -2081,  -2444,  -2979,  -3813,  -5323,  -8812, -26887};
/* lsp    code book   <../f7s55m1.v2> */

short lspcb1[NC0][M] = {        /* Q13 */
{ 1486,  2168,  3751,  9074, 12134, 13944, 17983, 19173, 21190, 21820},
{ 1730,  2640,  3450,  4870,  6126,  7876, 15644, 17817, 20294, 21902},
{ 1568,  2256,  3088,  4874, 11063, 13393, 18307, 19293, 21109, 21741},
{ 1733,  2512,  3357,  4708,  6977, 10296, 17024, 17956, 19145, 20350},
{ 1744,  2436,  3308,  8731, 10432, 12007, 15614, 16639, 21359, 21913},
{ 1786,  2369,  3372,  4521,  6795, 12963, 17674, 18988, 20855, 21640},
{ 1631,  2433,  3361,  6328, 10709, 12013, 13277, 13904, 19441, 21088},
{ 1489,  2364,  3291,  6250,  9227, 10403, 13843, 15278, 17721, 21451},
{ 1869,  2533,  3475,  4365,  9152, 14513, 15908, 17022, 20611, 21411},
{ 2070,  3025,  4333,  5854,  7805,  9231, 10597, 16047, 20109, 21834},
{ 1910,  2673,  3419,  4261, 11168, 15111, 16577, 17591, 19310, 20265},
{ 1141,  1815,  2624,  4623,  6495,  9588, 13968, 16428, 19351, 21286},
{ 2192,  3171,  4707,  5808, 10904, 12500, 14162, 15664, 21124, 21789},
{ 1286,  1907,  2548,  3453,  9574, 11964, 15978, 17344, 19691, 22495},
{ 1921,  2720,  4604,  6684, 11503, 12992, 14350, 15262, 16997, 20791},
{ 2052,  2759,  3897,  5246,  6638, 10267, 15834, 16814, 18149, 21675},
{ 1798,  2497,  5617, 11449, 13189, 14711, 17050, 18195, 20307, 21182},
{ 1009,  1647,  2889,  5709,  9541, 12354, 15231, 18494, 20966, 22033},
{ 3016,  3794,  5406,  7469, 12488, 13984, 15328, 16334, 19952, 20791},
{ 2203,  3040,  3796,  5442, 11987, 13512, 14931, 16370, 17856, 18803},
{ 2912,  4292,  7988,  9572, 11562, 13244, 14556, 16529, 20004, 21073},
{ 2861,  3607,  5923,  7034,  9234, 12054, 13729, 18056, 20262, 20974},
{ 3069,  4311,  5967,  7367, 11482, 12699, 14309, 16233, 18333, 19172},
{ 2434,  3661,  4866,  5798, 10383, 11722, 13049, 15668, 18862, 19831},
{ 2020,  2605,  3860,  9241, 13275, 14644, 16010, 17099, 19268, 20251},
{ 1877,  2809,  3590,  4707, 11056, 12441, 15622, 17168, 18761, 19907},
{ 2107,  2873,  3673,  5799, 13579, 14687, 15938, 17077, 18890, 19831},
{ 1612,  2284,  2944,  3572,  8219, 13959, 15924, 17239, 18592, 20117},
{ 2420,  3156,  6542, 10215, 12061, 13534, 15305, 16452, 18717, 19880},
{ 1667,  2612,  3534,  5237, 10513, 11696, 12940, 16798, 18058, 19378},
{ 2388,  3017,  4839,  9333, 11413, 12730, 15024, 16248, 17449, 18677},
{ 1875,  2786,  4231,  6320,  8694, 10149, 11785, 17013, 18608, 19960},
{  679,  1411,  4654,  8006, 11446, 13249, 15763, 18127, 20361, 21567},
{ 1838,  2596,  3578,  4608,  5650, 11274, 14355, 15886, 20579, 21754},
{ 1303,  1955,  2395,  3322, 12023, 13764, 15883, 18077, 20180, 21232},
{ 1438,  2102,  2663,  3462,  8328, 10362, 13763, 17248, 19732, 22344},
{  860,  1904,  6098,  7775,  9815, 12007, 14821, 16709, 19787, 21132},
{ 1673,  2723,  3704,  6125,  7668,  9447, 13683, 14443, 20538, 21731},
{ 1246,  1849,  2902,  4508,  7221, 12710, 14835, 16314, 19335, 22720},
{ 1525,  2260,  3862,  5659,  7342, 11748, 13370, 14442, 18044, 21334},
{ 1196,  1846,  3104,  7063, 10972, 12905, 14814, 17037, 19922, 22636},
{ 2147,  3106,  4475,  6511,  8227,  9765, 10984, 12161, 18971, 21300},
{ 1585,  2405,  2994,  4036, 11481, 13177, 14519, 15431, 19967, 21275},
{ 1778,  2688,  3614,  4680,  9465, 11064, 12473, 16320, 19742, 20800},
{ 1862,  2586,  3492,  6719, 11708, 13012, 14364, 16128, 19610, 20425},
{ 1395,  2156,  2669,  3386, 10607, 12125, 13614, 16705, 18976, 21367},
{ 1444,  2117,  3286,  6233,  9423, 12981, 14998, 15853, 17188, 21857},
{ 2004,  2895,  3783,  4897,  6168,  7297, 12609, 16445, 19297, 21465},
{ 1495,  2863,  6360,  8100, 11399, 14271, 15902, 17711, 20479, 22061},
{ 2484,  3114,  5718,  7097,  8400, 12616, 14073, 14847, 20535, 21396},
{ 2424,  3277,  5296,  6284, 11290, 12903, 16022, 17508, 19333, 20283},
{ 2565,  3778,  5360,  6989,  8782, 10428, 14390, 15742, 17770, 21734},
{ 2727,  3384,  6613,  9254, 10542, 12236, 14651, 15687, 20074, 21102},
{ 1916,  2953,  6274,  8088,  9710, 10925, 12392, 16434, 20010, 21183},
{ 3384,  4366,  5349,  7667, 11180, 12605, 13921, 15324, 19901, 20754},
{ 3075,  4283,  5951,  7619,  9604, 11010, 12384, 14006, 20658, 21497},
{ 1751,  2455,  5147,  9966, 11621, 13176, 14739, 16470, 20788, 21756},
{ 1442,  2188,  3330,  6813,  8929, 12135, 14476, 15306, 19635, 20544},
{ 2294,  2895,  4070,  8035, 12233, 13416, 14762, 17367, 18952, 19688},
{ 1937,  2659,  4602,  6697,  9071, 12863, 14197, 15230, 16047, 18877},
{ 2071,  2663,  4216,  9445, 10887, 12292, 13949, 14909, 19236, 20341},
{ 1740,  2491,  3488,  8138,  9656, 11153, 13206, 14688, 20896, 21907},
{ 2199,  2881,  4675,  8527, 10051, 11408, 14435, 15463, 17190, 20597},
{ 1943,  2988,  4177,  6039,  7478,  8536, 14181, 15551, 17622, 21579},
{ 1825,  3175,  7062,  9818, 12824, 15450, 18330, 19856, 21830, 22412},
{ 2464,  3046,  4822,  5977,  7696, 15398, 16730, 17646, 20588, 21320},
{ 2550,  3393,  5305,  6920, 10235, 14083, 18143, 19195, 20681, 21336},
{ 3003,  3799,  5321,  6437,  7919, 11643, 15810, 16846, 18119, 18980},
{ 3455,  4157,  6838,  8199,  9877, 12314, 15905, 16826, 19949, 20892},
{ 3052,  3769,  4891,  5810,  6977, 10126, 14788, 15990, 19773, 20904},
{ 3671,  4356,  5827,  6997,  8460, 12084, 14154, 14939, 19247, 20423},
{ 2716,  3684,  5246,  6686,  8463, 10001, 12394, 14131, 16150, 19776},
{ 1945,  2638,  4130,  7995, 14338, 15576, 17057, 18206, 20225, 20997},
{ 2304,  2928,  4122,  4824,  5640, 13139, 15825, 16938, 20108, 21054},
{ 1800,  2516,  3350,  5219, 13406, 15948, 17618, 18540, 20531, 21252},
{ 1436,  2224,  2753,  4546,  9657, 11245, 15177, 16317, 17489, 19135},
{ 2319,  2899,  4980,  6936,  8404, 13489, 15554, 16281, 20270, 20911},
{ 2187,  2919,  4610,  5875,  7390, 12556, 14033, 16794, 20998, 21769},
{ 2235,  2923,  5121,  6259,  8099, 13589, 15340, 16340, 17927, 20159},
{ 1765,  2638,  3751,  5730,  7883, 10108, 13633, 15419, 16808, 18574},
{ 3460,  5741,  9596, 11742, 14413, 16080, 18173, 19090, 20845, 21601},
{ 3735,  4426,  6199,  7363,  9250, 14489, 16035, 17026, 19873, 20876},
{ 3521,  4778,  6887,  8680, 12717, 14322, 15950, 18050, 20166, 21145},
{ 2141,  2968,  6865,  8051, 10010, 13159, 14813, 15861, 17528, 18655},
{ 4148,  6128,  9028, 10871, 12686, 14005, 15976, 17208, 19587, 20595},
{ 4403,  5367,  6634,  8371, 10163, 11599, 14963, 16331, 17982, 18768},
{ 4091,  5386,  6852,  8770, 11563, 13290, 15728, 16930, 19056, 20102},
{ 2746,  3625,  5299,  7504, 10262, 11432, 13172, 15490, 16875, 17514},
{ 2248,  3556,  8539, 10590, 12665, 14696, 16515, 17824, 20268, 21247},
{ 1279,  1960,  3920,  7793, 10153, 14753, 16646, 18139, 20679, 21466},
{ 2440,  3475,  6737,  8654, 12190, 14588, 17119, 17925, 19110, 19979},
{ 1879,  2514,  4497,  7572, 10017, 14948, 16141, 16897, 18397, 19376},
{ 2804,  3688,  7490, 10086, 11218, 12711, 16307, 17470, 20077, 21126},
{ 2023,  2682,  3873,  8268, 10255, 11645, 15187, 17102, 18965, 19788},
{ 2823,  3605,  5815,  8595, 10085, 11469, 16568, 17462, 18754, 19876},
{ 2851,  3681,  5280,  7648,  9173, 10338, 14961, 16148, 17559, 18474},
{ 1348,  2645,  5826,  8785, 10620, 12831, 16255, 18319, 21133, 22586},
{ 2141,  3036,  4293,  6082,  7593, 10629, 17158, 18033, 21466, 22084},
{ 1608,  2375,  3384,  6878,  9970, 11227, 16928, 17650, 20185, 21120},
{ 2774,  3616,  5014,  6557,  7788,  8959, 17068, 18302, 19537, 20542},
{ 1934,  4813,  6204,  7212,  8979, 11665, 15989, 17811, 20426, 21703},
{ 2288,  3507,  5037,  6841,  8278,  9638, 15066, 16481, 21653, 22214},
{ 2951,  3771,  4878,  7578,  9016, 10298, 14490, 15242, 20223, 20990},
{ 3256,  4791,  6601,  7521,  8644,  9707, 13398, 16078, 19102, 20249},
{ 1827,  2614,  3486,  6039, 12149, 13823, 16191, 17282, 21423, 22041},
{ 1000,  1704,  3002,  6335,  8471, 10500, 14878, 16979, 20026, 22427},
{ 1646,  2286,  3109,  7245, 11493, 12791, 16824, 17667, 18981, 20222},
{ 1708,  2501,  3315,  6737,  8729,  9924, 16089, 17097, 18374, 19917},
{ 2623,  3510,  4478,  5645,  9862, 11115, 15219, 18067, 19583, 20382},
{ 2518,  3434,  4728,  6388,  8082,  9285, 13162, 18383, 19819, 20552},
{ 1726,  2383,  4090,  6303,  7805, 12845, 14612, 17608, 19269, 20181},
{ 2860,  3735,  4838,  6044,  7254,  8402, 14031, 16381, 18037, 19410},
{ 4247,  5993,  7952,  9792, 12342, 14653, 17527, 18774, 20831, 21699},
{ 3502,  4051,  5680,  6805,  8146, 11945, 16649, 17444, 20390, 21564},
{ 3151,  4893,  5899,  7198, 11418, 13073, 15124, 17673, 20520, 21861},
{ 3960,  4848,  5926,  7259,  8811, 10529, 15661, 16560, 18196, 20183},
{ 4499,  6604,  8036,  9251, 10804, 12627, 15880, 17512, 20020, 21046},
{ 4251,  5541,  6654,  8318,  9900, 11686, 15100, 17093, 20572, 21687},
{ 3769,  5327,  7865,  9360, 10684, 11818, 13660, 15366, 18733, 19882},
{ 3083,  3969,  6248,  8121,  9798, 10994, 12393, 13686, 17888, 19105},
{ 2731,  4670,  7063,  9201, 11346, 13735, 16875, 18797, 20787, 22360},
{ 1187,  2227,  4737,  7214,  9622, 12633, 15404, 17968, 20262, 23533},
{ 1911,  2477,  3915, 10098, 11616, 12955, 16223, 17138, 19270, 20729},
{ 1764,  2519,  3887,  6944,  9150, 12590, 16258, 16984, 17924, 18435},
{ 1400,  3674,  7131,  8718, 10688, 12508, 15708, 17711, 19720, 21068},
{ 2322,  3073,  4287,  8108,  9407, 10628, 15862, 16693, 19714, 21474},
{ 2630,  3339,  4758,  8360, 10274, 11333, 12880, 17374, 19221, 19936},
{ 1721,  2577,  5553,  7195,  8651, 10686, 15069, 16953, 18703, 19929}
};


short lspcb2[NC1][M] = {        /* Q13 */
{ -435,  -815,  -742,  1033,  -518,   582, -1201,   829,    86,   385},
{ -833,  -891,   463,    -8, -1251,  1450,    72,  -231,   864,   661},
{-1021,   231,  -306,   321,  -220,  -163,  -526,  -754, -1633,   267},
{   57,  -198,  -339,   -33, -1468,   573,   796,  -169,  -631,   816},
{  171,  -350,   294,  1660,   453,   519,   291,   159,  -640, -1296},
{ -701,  -842,   -58,   950,   892,  1549,   715,   527,  -714,  -193},
{  584,    31,  -289,   356,  -333,  -457,   612,  -283, -1381,  -741},
{ -109,  -808,   231,    77,   -87,  -344,  1341,  1087,  -654,  -569},
{ -859,  1236,   550,   854,   714,  -543, -1752,  -195,   -98,  -276},
{ -877,  -954, -1248,  -299,   212,  -235,  -728,   949,  1517,   895},
{  -77,   344,  -620,   763,   413,   502,  -362,  -960,  -483,  1386},
{ -314,  -307,  -256, -1260,  -429,   450,  -466,  -108,  1010,  2223},
{  711,   693,   521,   650,  1305,   -28,  -378,   744, -1005,   240},
{ -112,  -271,  -500,   946,  1733,   271,   -15,   909,  -259,  1688},
{  575,   -10,  -468,  -199,  1101, -1011,   581,   -53,  -747,   878},
{  145,  -285, -1280,  -398,    36,  -498, -1377,    18,  -444,  1483},
{-1133,  -835,  1350,  1284,   -95,  1015,  -222,   443,   372,  -354},
{-1459, -1237,   416,  -213,   466,   669,   659,  1640,   932,   534},
{  -15,    66,   468,  1019,  -748,  1385,  -182,  -907,  -721,  -262},
{ -338,   148,  1445,    75,  -760,   569,  1247,   337,   416,  -121},
{  389,   239,  1568,   981,   113,   369, -1003,  -507,  -587,  -904},
{ -312,   -98,   949,    31,  1104,    72,  -141,  1465,    63,  -785},
{ 1127,   584,   835,   277, -1159,   208,   301,  -882,   117,  -404},
{  539,  -114,   856,  -493,   223,  -912,   623,   -76,   276,  -440},
{ 2197,  2337,  1268,   670,   304,  -267,  -525,   140,   882,  -139},
{-1596,   550,   801,  -456,   -56,  -697,   865,  1060,   413,   446},
{ 1154,   593,   -77,  1237,   -31,   581, -1037,  -895,   669,   297},
{  397,   558,   203,  -797,  -919,     3,   692,  -292,  1050,   782},
{  334,  1475,   632,   -80,    48, -1061,  -484,   362,  -597,  -852},
{ -545,  -330,  -429,  -680,  1133, -1182,  -744,  1340,   262,    63},
{ 1320,   827,  -398,  -576,   341,  -774,  -483, -1247,   -70,    98},
{ -163,   674,   -11,  -886,   531, -1125,  -265,  -242,   724,   934}
};
short fg[2][MA_NP][M] = {       /* Q15 */
  {
    { 8421,  9109,  9175,  8965,  9034,  9057,  8765,  8775,  9106,  8673},
    { 7018,  7189,  7638,  7307,  7444,  7379,  7038,  6956,  6930,  6868},
    { 5472,  4990,  5134,  5177,  5246,  5141,  5206,  5095,  4830,  5147},
    { 4056,  3031,  2614,  3024,  2916,  2713,  3309,  3237,  2857,  3473}
  },
  {
    { 7733,  7880,  8188,  8175,  8247,  8490,  8637,  8601,  8359,  7569},
    { 4210,  3031,  2552,  3473,  3876,  3853,  4184,  4154,  3909,  3968},
    { 3214,  1930,  1313,  2143,  2493,  2385,  2755,  2706,  2542,  2919},
    { 3024,  1592,   940,  1631,  1723,  1579,  2034,  2084,  1913,  2601}
  }
};
short fg_sum[2][M] = {{ 7798,  8447,  8205,  8293,  8126,  8477,  8447,  8703,  9043,  8604},{14585, 18333, 19772, 17344, 16426, 16459, 15155, 15220, 16043, 15708}};/* Q15 */
short fg_sum_inv[2][M]={{17210, 15888, 16357, 16183, 16516, 15833, 15888, 15421, 14840, 15597},{ 9202,  7320,  6788,  7738,  8170,  8154,  8856,  8818,  8366,  8544}};/* Q12 */

//  Table for az_lsf();  Vector grid[] is in Q15; grid[0] = 1.0; grid[grid_points+1] = -1.0; for (i = 1; i < grid_points; i++) grid[i] = cos((6.283185307*i)/(2.0*grid_points)); 
/* Version 51 points */
short grid[GRID_POINTS+1] ={
     32760,     32703,     32509,     32187,     31738,     31164,     30466,     29649,     28714,     27666,     26509,     25248,
     23886,     22431,     20887,     19260,     17557,     15786,     13951,     12062,     10125,      8149,      6140,      4106,
      2057,         0,     -2057,     -4106,     -6140,     -8149,    -10125,    -12062,    -13951,    -15786,    -17557,    -19260,
    -20887,    -22431,    -23886,    -25248,    -26509,    -27666,    -28714,    -29649,    -30466,    -31164,    -31738,    -32187,  -32509,    -32703,    -32760};

/* 1/3 resolution interpolation filter  (-3 dB at 3600 Hz)  in Q15 */
short inter_3l[FIR_SIZE_SYN] = {   29443,   25207,   14701,    3143,   -4402,   -5850,   -2783,    1211,    3130,    2259,       0,   -1652,   -1666,
    -464,     756,    1099,     550,    -245,    -634,    -451,       0,     308,     296,      78,    -120,    -165,     -79,      34,      91,      70,       0};

   /*Coefficients in floating point

   0.898517,
   0.769271,   0.448635,   0.095915,
  -0.134333,  -0.178528,  -0.084919,
   0.036952,   0.095533,   0.068936,
  -0.000000,  -0.050404,  -0.050835,
  -0.014169,   0.023083,   0.033543,
   0.016774,  -0.007466,  -0.019340,
  -0.013755,   0.000000,   0.009400,
   0.009029,   0.002381,  -0.003658,
  -0.005027,  -0.002405,   0.001050,
   0.002780,   0.002145,   0.000000};
  */

/*-----------------------------------------------------*
 | Tables for gain related routines .                  |
 -----------------------------------------------------*/

/* MA gain prediction coeff ={0.68, 0.58, 0.34, 0.19} in Q13 */
short pred[4] = { 5571, 4751, 2785, 1556 };


short gbk1[NCODE1][2] = {{1 ,1516 }, {1551 ,2425 }, { 1831 ,5022 }, {57 ,5404 },{1921 ,9291 },{3242 ,  9949 }, { 356 , 14756 }, { 2678 , 27162 }};/* Q14      Q13 */

short gbk2[NCODE2][2] = { {   826 ,  2005 }, {  1994 ,     0 }, {  5142 ,   592 }, {  6160 ,  2395 }, {  8091 ,  4861 }, {  9120 ,   525 }, { 10573 ,  2966 },
 { 11569 ,  1196 }, { 13260 ,  3256 }, { 14194 ,  1630 }, { 15132 ,  4914 }, { 15161 , 14276 }, { 15434 ,   237 }, { 16112 ,  3392 }, { 17299 ,  1861 }, { 18973 ,  5935 }};/* Q14       Q13 */

short map1[NCODE1] = { 5, 1, 4, 7, 3, 0, 6, 2};
short map2[NCODE2] = { 4, 6, 0, 2,12,14, 8,10,15,11, 9,13, 7, 3, 1, 5};

/*  [0][0]      [0][1]       [1][0]     [1][1]    */
/*  Q10         Q14          Q16        Q19       */
short coef[2][2] = {   { 31881 , 26416 },   { 31548 , 27816 }};
/*  [0][0]      [0][1]       [1][0]     [1][1]    */
/*  Q26         Q30          Q32        Q35       */
int L_coef[2][2] = {   { 2089405952L , 1731217536L },   { 2067549984L , 1822990272L }};
short thr1[NCODE1-NCAN1] = {    10808 ,   12374 ,   19778 ,   32567}; /* Q14 */
short thr2[NCODE2-NCAN2] = {   14087 ,   16188 ,   20274 ,   21321 ,   23525 ,   25232 ,   27873 ,   30542};  /* Q15 */
short imap1[NCODE1] = { 5, 1, 7, 4, 2, 0, 6, 3};
short imap2[NCODE2] = { 2,14, 3,13, 0,15, 1,12, 6,10, 7, 9, 4,11, 5, 8};
short b100[3] = {7699, -15398, 7699};      /* Q13 */
short a100[3] = {8192, 15836, -7667};      /* Q13 */
/* filter coefficients (fc = 140 Hz, coeff. b[] is divided by 2) */
short b140[3] = {1899, -3798, 1899};      /* 1/2 in Q12 */
short a140[3] = {4096, 7807, -3733};      /* Q12 */
short bitsno[PRM_SIZE] = {1+NC0_B,    NC1_B*2,  8, 1, 13, 4, 7,  5,    13, 4, 7};/* MA + 1st stage /* 2nd stage //* first subframe  /* second subframe  */

/*-----------------------------------------------------*
 | Table for routine Pow2().                           |
 -----------------------------------------------------*/
short tabpow[33] = { 16384, 16743, 17109, 17484, 17867, 18258, 18658, 19066, 19484, 19911,
 20347, 20792, 21247, 21713, 22188, 22674, 23170, 23678, 24196, 24726, 25268, 25821, 26386, 26964, 27554, 28158, 28774, 29405, 30048, 30706, 31379, 32066, 32767 };

/*-----------------------------------------------------*
 | Table for routine Log2().                           |
 -----------------------------------------------------*/
short tablog[33] = { 0,  1455,  2866,  4236,  5568,  6863,  8124,  9352, 10549, 11716,
 12855, 13967, 15054, 16117, 17156, 18172, 19167, 20142, 21097, 22033, 22951, 23852, 24735, 25603, 26455, 27291, 28113, 28922, 29716, 30497, 31266, 32023, 32767 };
/*-----------------------------------------------------*
 | Table for routine Inv_sqrt().                       |
 -----------------------------------------------------*/
short tabsqr[49] = { 32767, 31790, 30894, 30070, 29309, 28602, 27945, 27330, 26755, 26214, 25705, 25225, 24770, 24339, 23930, 23541, 23170, 22817, 22479, 22155,
 21845, 21548, 21263, 20988, 20724, 20470, 20225, 19988, 19760, 19539, 19326, 19119, 18919, 18725, 18536, 18354, 18176, 18004, 17837, 17674, 17515, 17361, 17211, 17064, 16921, 16782, 16646, 16514, 16384 };
/*-----------------------------------------------------*
 | Table for taming procedure test_err.                |
 -----------------------------------------------------*/
short tab_zone[PIT_MAX+L_INTERPOL-1] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };

/*-------------------------------* * Mathematic functions.         * *-------------------------------*/
int Inv_sqrt(int L_x);   /* (o) Q30 : output value   (range: 0<=val<1)  /* (i) Q0  : input value    (range: 0<=val<=7fffffff)   */
void Log2(  int L_x,   short *exponent,  short *fraction); /* (i) Q0 : input value  /* (o) Q0 : Integer part of Log2.   (range: 0<=val<=30) */ /* (o) Q15: Fractionnal part of Log2. (range: 0<=val<1) */
int Pow2( short exponent,  short fraction );         /* (o) Q0  : result       (range: 0<=val<=0x7fffffff) */ /* (i) Q0  : Integer part.      (range: 0<=val<=30)   */  /* (i) Q15 : Fractionnal part.  (range: 0.0<=val<1.0) */

void Init_Pre_Process(void);
void Init_Post_Process(void);
void Pre_Process(  short signal[], short lg );    /* Input/output signal */       /* Length of signal    */
void Post_Process( short signal[],  short lg);    /* Input/output signal */ /* Length of signal    */
void Init_Coder_ld8a(void);
void Coder_ld8a( short ana[] );      /* output  : Analysis parameters */
void Init_Decod_ld8a(void);
void Decod_ld8a( short  parm[], short  synth[], short  A_t[],  short  *T2);  /* (o) : decoded LP filter in 2 subframes     */      /* (o)   : decoded pitch lag in 2 subframes     */    /* (o)   : synthesis speech                     */   /* (i)   : vector of synthesis parameters  parm[0] = bad frame indicator (bfi)  */
void Autocorr(  short x[], short m, short r_h[], short r_l[]);  /* (i): Input signal  (i)    : LPC order  : Autocorrelations  (msb)   : Autocorrelations  (lsb) */
void Lag_window(short m,  short r_h[],   short r_l[] );        /* (i)     : LPC order   (i/o)   : Autocorrelations  (msb)          */    /* (i/o)   : Autocorrelations  (lsb)          */
void Levinson( short Rh[], short Rl[], short A[], short rc[]);/* (i)     : Rh[m+1] Vector of autocorrelations (msb) */     /* (i)     : Rl[m+1] Vector of autocorrelations (lsb) */     /* (o) Q12 : A[m]    LPC coefficients  (m = 10)       */      /* (o) Q15 : rc[M]   Relection coefficients.          */
void Az_lsp(short a[], short lsp[], short old_lsp[]);   /* (i) Q12 : predictor coefficients              */     /* (o) Q15 : line spectral pairs                 */  /* (i)     : old lsp[] (in case not found 10 roots) */
void Lsp_Az(
  short lsp[],    /* (i) Q15 : line spectral frequencies            */
  short a[]       /* (o) Q12 : predictor coefficients (order = 10)  */
);

void Lsf_lsp(
  short lsf[],    /* (i) Q15 : lsf[m] normalized (range: 0.0<=val<=0.5) */
  short lsp[],    /* (o) Q15 : lsp[m] (range: -1<=val<1)                */
  short m         /* (i)     : LPC order                                */
);

void Lsp_lsf(
  short lsp[],    /* (i) Q15 : lsp[m] (range: -1<=val<1)                */
  short lsf[],    /* (o) Q15 : lsf[m] normalized (range: 0.0<=val<=0.5) */
  short m         /* (i)     : LPC order                                */
);

void Int_qlpc(
 short lsp_old[], /* input : LSP vector of past frame              */
 short lsp_new[], /* input : LSP vector of present frame           */
 short Az[]       /* output: interpolated Az() for the 2 subframes */
);

void Weight_Az(
  short a[],      /* (i) Q12 : a[m+1]  LPC coefficients             */
  short gamma,    /* (i) Q15 : Spectral expansion factor.           */
  short m,        /* (i)     : LPC order.                           */
  short ap[]      /* (o) Q12 : Spectral expanded LPC coefficients   */
);

void Residu(
  short a[],    /* (i) Q12 : prediction coefficients                     */
  short x[],    /* (i)     : speech (values x[-m..-1] are needed (m=10)  */
  short y[],    /* (o)     : residual signal                             */
  short lg      /* (i)     : size of filtering                           */
);

void Syn_filt(
  short a[],     /* (i) Q12 : a[m+1] prediction coefficients   (m=10)  */
  short x[],     /* (i)     : input signal                             */
  short y[],     /* (o)     : output signal                            */
  short lg,      /* (i)     : size of filtering                        */
  short mem[],   /* (i/o)   : memory associated with this filtering.   */
  short update   /* (i)     : 0=no update, 1=update of memory.         */
);

void Convolve(
  short x[],      /* (i)     : input vector                           */
  short h[],      /* (i) Q12 : impulse response                       */
  short y[],      /* (o)     : output vector                          */
  short L         /* (i)     : vector size                            */
);

/*--------------------------------------------------------------------------*
 *       LTP constant parameters                                            *
 *--------------------------------------------------------------------------*/



/*-----------------------*
 * Pitch functions.      *
 *-----------------------*/

short Pitch_ol_fast(  /* output: open loop pitch lag                        */
   short signal[],    /* input : signal used to compute the open loop pitch */
                       /*     signal[-pit_max] to signal[-1] should be known */
   short   pit_max,   /* input : maximum pitch lag                          */
   short   L_frame    /* input : length of frame to compute pitch           */
);

short Pitch_fr3_fast(/* (o)     : pitch period.                          */
  short exc[],       /* (i)     : excitation buffer                      */
  short xn[],        /* (i)     : target vector                          */
  short h[],         /* (i) Q12 : impulse response of filters.           */
  short L_subfr,     /* (i)     : Length of subframe                     */
  short t0_min,      /* (i)     : minimum value in the searched range.   */
  short t0_max,      /* (i)     : maximum value in the searched range.   */
  short i_subfr,     /* (i)     : indicator for first subframe.          */
  short *pit_frac    /* (o)     : chosen fraction.                       */
);

short G_pitch(      /* (o) Q14 : Gain of pitch lag saturated to 1.2       */
  short xn[],       /* (i)     : Pitch target.                            */
  short y1[],       /* (i)     : Filtered adaptive codebook.              */
  short g_coeff[],  /* (i)     : Correlations need for gain quantization. */
  short L_subfr     /* (i)     : Length of subframe.                      */
);

short Enc_lag3(     /* output: Return index of encoding */
  short T0,         /* input : Pitch delay              */
  short T0_frac,    /* input : Fractional pitch delay   */
  short *T0_min,    /* in/out: Minimum search delay     */
  short *T0_max,    /* in/out: Maximum search delay     */
  short pit_min,    /* input : Minimum pitch delay      */
  short pit_max,    /* input : Maximum pitch delay      */
  short pit_short    /* input : short for 1st subframe    */
);

void Dec_lag3(        /* output: return integer pitch lag       */
  short index,       /* input : received pitch index           */
  short pit_min,     /* input : minimum pitch lag              */
  short pit_max,     /* input : maximum pitch lag              */
  short i_subfr,     /* input : subframe short                  */
  short *T0,         /* output: integer part of pitch lag      */
  short *T0_frac     /* output: fractional part of pitch lag   */
);

short Interpol_3(      /* (o)  : interpolated value  */
  short *x,            /* (i)  : input vector        */
  short frac           /* (i)  : fraction            */
);

void Pred_lt_3(
  short   exc[],       /* in/out: excitation buffer */
  short   T0,          /* input : integer pitch lag */
  short   frac,        /* input : fraction of lag   */
  short   L_subfr      /* input : subframe size     */
);

short Parity_Pitch(    /* output: parity bit (XOR of 6 MSB bits)    */
   short pitch_index   /* input : index for which parity to compute */
);

short  Check_Parity_Pitch( /* output: 0 = no error, 1= error */
  short pitch_index,       /* input : index of parameter     */
  short parity             /* input : parity bit             */
);

void Cor_h_X(
     short h[],        /* (i) Q12 :Impulse response of filters      */
     short X[],        /* (i)     :Target vector                    */
     short D[]         /* (o)     :Correlations between h[] and D[] */
                        /*          Normalized to 13 bits            */
);

/*-----------------------*
 * Innovative codebook.  *
 *-----------------------*/



short  ACELP_Code_A(    /* (o)     :index of pulses positions    */
  short x[],            /* (i)     :Target vector                */
  short h[],            /* (i) Q12 :Inpulse response of filters  */
  short T0,             /* (i)     :Pitch lag                    */
  short pitch_sharp,    /* (i) Q14 :Last quantized pitch gain    */
  short code[],         /* (o) Q13 :Innovative codebook          */
  short y[],            /* (o) Q12 :Filtered innovative codebook */
  short *sign           /* (o)     :Signs of 4 pulses            */
);

void Decod_ACELP(
  short sign,      /* (i)     : signs of 4 pulses.                       */
  short index,     /* (i)     : Positions of the 4 pulses.               */
  short cod[]      /* (o) Q13 : algebraic (fixed) codebook excitation    */
);
/*--------------------------------------------------------------------------*
 *       LSP constant parameters                                            *
 *--------------------------------------------------------------------------*/



/*-------------------------------*
 * LSP VQ functions.             *
 *-------------------------------*/

void Lsf_lsp2(
  short lsf[],    /* (i) Q13 : lsf[m] (range: 0.0<=val<PI) */
  short lsp[],    /* (o) Q15 : lsp[m] (range: -1<=val<1)   */
  short m         /* (i)     : LPC order                   */
);

void Lsp_lsf2(
  short lsp[],    /* (i) Q15 : lsp[m] (range: -1<=val<1)   */
  short lsf[],    /* (o) Q13 : lsf[m] (range: 0.0<=val<PI) */
  short m         /* (i)     : LPC order                   */
);

void Qua_lsp(
  short lsp[],       /* (i) Q15 : Unquantized LSP            */
  short lsp_q[],     /* (o) Q15 : Quantized LSP              */
  short ana[]        /* (o)     : indexes                    */
);

void Get_wegt(
  short flsp[],    /* Q13 */
  short wegt[]     /* Q11 -> normalized */
);

void Lsp_encw_reset(
  void
);

void Lsp_qua_cs(
  short flsp_in[M],    /* Q13 */
  short lspq_out[M],   /* Q13 */
  short *code
);

void Lsp_expand_1(
  short buf[],          /* Q13 */
  short gap             /* Q13 */
);

void Lsp_expand_2(
  short buf[],         /* Q13 */
  short gap            /* Q13 */
);

void Lsp_expand_1_2(
  short buf[],         /* Q13 */
  short gap            /* Q13 */
);

void Lsp_get_quant(
  short lspcb1[][M],      /* Q13 */
  short lspcb2[][M],      /* Q13 */
  short code0,
  short code1,
  short code2,
  short fg[][M],            /* Q15 */
  short freq_prev[][M],     /* Q13 */
  short lspq[],                /* Q13 */
  short fg_sum[]               /* Q15 */
);

void Lsp_get_tdist(
  short wegt[],        /* normalized */
  short buf[],         /* Q13 */
  int *L_tdist,      /* Q27 */
  short rbuf[],        /* Q13 */
  short fg_sum[]       /* Q15 */
);

void Lsp_last_select(
  int L_tdist[],     /* Q27 */
  short *mode_index
);

void Lsp_pre_select(
  short rbuf[],              /* Q13 */
  short lspcb1[][M],      /* Q13 */
  short *cand
);

void Lsp_select_1(
  short rbuf[],              /* Q13 */
  short lspcb1[],            /* Q13 */
  short wegt[],              /* normalized */
  short lspcb2[][M],      /* Q13 */
  short *index
);

void Lsp_select_2(
  short rbuf[],              /* Q13 */
  short lspcb1[],            /* Q13 */
  short wegt[],              /* normalized */
  short lspcb2[][M],      /* Q13 */
  short *index
);

void Lsp_stability(
  short buf[]     /* Q13 */
);

void Relspwed(
  short lsp[],                          /* Q13 */
  short wegt[],                         /* normalized */
  short lspq[],                         /* Q13 */
  short lspcb1[][M],                 /* Q13 */
  short lspcb2[][M],                 /* Q13 */
  short fg[MODE][MA_NP][M],          /* Q15 */
  short freq_prev[MA_NP][M],         /* Q13 */
  short fg_sum[MODE][M],             /* Q15 */
  short fg_sum_inv[MODE][M],         /* Q12 */
  short code_ana[]
);

void D_lsp(
  short prm[],          /* (i)     : indexes of the selected LSP */
  short lsp_q[],        /* (o) Q15 : Quantized LSP parameters    */
  short erase           /* (i)     : frame erase information     */
);

void Lsp_decw_reset(
  void
);

void Lsp_iqua_cs(
 short prm[],          /* input : codes of the selected LSP*/
 short lsp_q[],        /* output: Quantized LSP parameters*/
 short erase           /* input : frame erase information */
);

void Lsp_prev_compose(
  short lsp_ele[],             /* Q13 */
  short lsp[],                 /* Q13 */
  short fg[][M],            /* Q15 */
  short freq_prev[][M],     /* Q13 */
  short fg_sum[]               /* Q15 */
);

void Lsp_prev_extract(
  short lsp[M],                 /* Q13 */
  short lsp_ele[M],             /* Q13 */
  short fg[MA_NP][M],           /* Q15 */
  short freq_prev[MA_NP][M],    /* Q13 */
  short fg_sum_inv[M]           /* Q12 */
);

void Lsp_prev_update(
  short lsp_ele[M],             /* Q13 */
  short freq_prev[MA_NP][M]     /* Q13 */
);

/*-------------------------------*
 * gain VQ constants.            *
 *-------------------------------*/


/*--------------------------------------------------------------------------*
 * gain VQ functions.                                                       *
 *--------------------------------------------------------------------------*/

short Qua_gain(
  short code[],    /* (i) Q13 : Innovative vector.                         */
  short g_coeff[], /* (i)     : Correlations <xn y1> -2<y1 y1>             */
                    /*            <y2,y2>, -2<xn,y2>, 2<y1,y2>              */
  short exp_coeff[],/* (i)    : Q-Format g_coeff[]                         */
  short L_subfr,   /* (i)     : Subframe length.                           */
  short *gain_pit, /* (o) Q14 : Pitch gain.                                */
  short *gain_cod, /* (o) Q1  : Code gain.                                 */
  short tameshort   /* (i)     : short set to 1 if taming is needed          */
);

void Dec_gain(
  short index,     /* (i)     : Index of quantization.                     */
  short code[],    /* (i) Q13 : Innovative vector.                         */
  short L_subfr,   /* (i)     : Subframe length.                           */
  short bfi,       /* (i)     : Bad frame indicator                        */
  short *gain_pit, /* (o) Q14 : Pitch gain.                                */
  short *gain_cod  /* (o) Q1  : Code gain.                                 */
);

void Gain_predict(
  short past_qua_en[],/* (i) Q10 :Past quantized energies                  */
  short code[],    /* (i) Q13 : Innovative vector.                         */
  short L_subfr,   /* (i)     : Subframe length.                           */
  short *gcode0,   /* (o) Qxx : Predicted codebook gain                    */
  short *exp_gcode0 /* (o)    : Q-Format(gcode0)                           */
);

void Gain_update(
  short past_qua_en[],/* (i) Q10 :Past quantized energies                  */
  int L_gbk12    /* (i) Q13 : gbk1[indice1][1]+gbk2[indice2][1]          */
);

void Gain_update_erasure(
  short past_qua_en[]/* (i) Q10 :Past quantized energies                   */
);

void Corr_xy2(
      short xn[],           /* (i) Q0  :Target vector.                  */
      short y1[],           /* (i) Q0  :Adaptive codebook.              */
      short y2[],           /* (i) Q12 :Filtered innovative vector.     */
      short g_coeff[],      /* (o) Q[exp]:Correlations between xn,y1,y2 */
      short exp_g_coeff[]   /* (o)       :Q-format of g_coeff[]         */
);

/*-----------------------*
 * Bitstream function    *
 *-----------------------*/

void  prm2bits_ld8k(short prm[], short bits[]);
void  bits2prm_ld8k(short bits[], short prm[]);



void Init_Post_Filter(void);

void Post_Filter(
  short *syn,       /* in/out: synthesis speech (postfiltered is output)    */
  short *Az_4,       /* input : interpolated LPC parameters in all subframes */
  short *T            /* input : decoded pitch lags in all subframes          */
);

void pit_pst_filt(
  short *signal,      /* (i)     : input signal                        */
  short *scal_sig,    /* (i)     : input signal (scaled, divided by 4) */
  short t0_min,       /* (i)     : minimum value in the searched range */
  short t0_max,       /* (i)     : maximum value in the searched range */
  short L_subfr,      /* (i)     : size of filtering                   */
  short *signal_pst   /* (o)     : harmonically postfiltered signal    */
);

void preemphasis(
  short *signal,  /* (i/o)   : input signal overwritten by the output */
  short g,        /* (i) Q15 : preemphasis coefficient                */
  short L         /* (i)     : size of filtering                      */
);

void agc( short *sig_in, short *sig_out, short l_trm);  /* (i)     : postfilter input signal  */ /* (i/o)   : postfilter output signal  (i) : subframe size */
void   Init_exc_err(void);
void   update_exc_err(short gain_pit, short t0);
short test_err(short t0, short t0_frac);

void Copy(short x[], short y[], short L );  /* (i)   : input vector   */     /* (o)   : output vector  */        /* (i)   : vector length  */
void Set_zero( short x[], short L);        /* (o)    : vector to clear     */        /* (i)    : length of vector    */
short Random(void);

extern short Overflow=0;
extern short Carry=0;

static short old_exc[L_FRAME+PIT_MAX+L_INTERPOL];
static short *exc;        /* Lsp (Line spectral pairs) */
static short lsp_old[M]={  30000, 26000, 21000, 15000, 8000, 0, -8000,-15000,-21000,-26000};
        /* Filter's memory */
static short mem_syn[M];
static short sharp;           /* pitch sharpening of previous frame */
static short old_T0;          /* integer delay of previous frame    */
static short gain_code;       /* Code gain                          */
static short gain_pitch;      /* Pitch gain                         */

short sature(int L_var1);             /* Limit to 16 bits,    1 */
short add(short var1, short var2);     /* Short add,           1 */
short sub(short var1, short var2);     /* Short sub,           1 */
short abs_s(short var1);                /* Short abs,           1 */
short shl(short var1, short var2);     /* Short shift left,    1 */
short shr(short var1, short var2);     /* Short shift right,   1 */
short mult(short var1, short var2);    /* Short mult,          1 */
int L_mult(short var1, short var2);  /* Long mult,           1 */
short negate(short var1);               /* Short negate,        1 */
short extract_h(int L_var1);          /* Extract high,        1 */
short extract_l(int L_var1);          /* Extract low,         1 */
short round(int L_var1);              /* Round,               1 */
int L_mac(int L_var3, short var1, short var2); /* Mac,    1 */
int L_msu(int L_var3, short var1, short var2); /* Msu,    1 */
int L_macNs(int L_var3, short var1, short var2);/* Mac without sat, 1*/
int L_msuNs(int L_var3, short var1, short var2);/* Msu without sat, 1*/

int L_add(int L_var1, int L_var2);   /* Long add,        2 */
int L_sub(int L_var1, int L_var2);   /* Long sub,        2 */
int L_add_c(int L_var1, int L_var2); /*Long add with c,  2 */
int L_sub_c(int L_var1, int L_var2); /*Long sub with c,  2 */
int L_negate(int L_var1);               /* Long negate,     2 */
short mult_r(short var1, short var2);  /* Mult with round,     2 */
int L_shl(int L_var1, short var2); /* Long shift left,     2 */
int L_shr(int L_var1, short var2); /* Long shift right,    2 */
short shr_r(short var1, short var2);/* Shift right with round, 2 */
short mac_r(int L_var3, short var1, short var2);/* Mac with rounding, 2*/
short msu_r(int L_var3, short var1, short var2);/* Msu with rounding, 2*/
int L_deposit_h(short var1);       /* 16 bit var1 -> MSB,     2 */
int L_deposit_l(short var1);       /* 16 bit var1 -> LSB,     2 */

int L_shr_r(int L_var1, short var2);/* Long shift right with round,  3*/
int L_abs(int L_var1);            /* Long abs,              3 */

int L_sat(int L_var1);            /* Long saturation,       4 */

short norm_s(short var1);             /* Short norm,           15 */

short div_s(short var1, short var2); /* Short division,       18 */

short norm_l(int L_var1);           /* Long norm,            30 */


void   L_Extract(int L_32, short *hi, short *lo);
int L_Comp(short hi, short lo);
int Mpy_32(short hi1, short lo1, short hi2, short lo2);
int Mpy_32_16(short hi, short lo, short n);
int Div_32(int L_num, short denom_hi, short denom_lo);


static void  int2bin(short value, short no_of_bits, short *bitstream);
static short   bin2int(short no_of_bits, short *bitstream);
static short freq_prev[MA_NP][M];   /* Q13 */
static short freq_prev_reset[M] = {   2339, 4679, 7018, 9358, 11698, 14037, 16377, 18717, 21056, 23396};  /* Q13 */   /* PI*(float)(j+1)/(float)(M+1) */
/* static memory for frame erase operation */
static short prev_ma;                  /* previous MA prediction coef.*/
static short prev_lsp[M];              /* previous LSP vector         */
static short y2_hi, y2_lo, y1_hi, y1_lo, x0, x1;
static short res2_buf[PIT_MAX+L_SUBFR];
static short *res2;
static short scal_res2_buf[PIT_MAX+L_SUBFR];
static short *scal_res2;       /* memory of filter 1/A(z/GAMMA1_PST) */
static short mem_syn_pst[M];
extern short hamwindow[L_WINDOW];
extern short lag_h[M];
extern short lag_l[M];
extern short table[65];
extern short slope[64];
extern short table2[64];
extern short slope_cos[64];
extern short slope_acos[64];
extern short lspcb1[NC0][M];
extern short lspcb2[NC1][M];
extern short fg[2][MA_NP][M];
extern short fg_sum[2][M];
extern short fg_sum_inv[2][M];
extern short grid[GRID_POINTS+1];
extern short inter_3l[FIR_SIZE_SYN];
extern short pred[4];
extern short gbk1[NCODE1][2];
extern short gbk2[NCODE2][2];
extern short map1[NCODE1];
extern short map2[NCODE2];
extern short coef[2][2];
extern int L_coef[2][2];
extern short thr1[NCODE1-NCAN1];
extern short thr2[NCODE2-NCAN2];
extern short imap1[NCODE1];
extern short imap2[NCODE2];
extern short b100[3];
extern short a100[3];
extern short b140[3];
extern short a140[3];
extern short bitsno[PRM_SIZE];
extern short tabpow[33];
extern short tablog[33];
extern short tabsqr[49];
extern short tab_zone[PIT_MAX+L_INTERPOL-1];

   

void Set_zero(
  short x[],       /* (o)    : vector to clear     */
  short L          /* (i)    : length of vector    */
)
{
   short i;

   for (i = 0; i < L; i++)
     x[i] = 0;

   return;
}
/*-------------------------------------------------------------------*
 * Function  Copy:                                                   *
 *           ~~~~~                                                   *
 * Copy vector x[] to y[]                                            *
 *-------------------------------------------------------------------*/

void Copy(
  short x[],      /* (i)   : input vector   */
  short y[],      /* (o)   : output vector  */
  short L         /* (i)   : vector length  */
)
{
   short i;

   for (i = 0; i < L; i++)
     y[i] = x[i];

   return;
}

/* Random generator  */

short Random()
{
  static short seed = 21845;

  /* seed = seed*31821 + 13849; */
  seed = extract_l(L_add(L_shr(L_mult(seed, 31821), 1), 13849L));

  return(seed);
}
/*-------------------------------------------------------------------*
 * Function  Pred_lt_3()                                             *
 *           ~~~~~~~~~~~                                             *
 *-------------------------------------------------------------------*
 * Compute the result of long term prediction with fractional        *
 * interpolation of resolution 1/3.                                  *
 *                                                                   *
 * On return exc[0..L_subfr-1] contains the interpolated signal      *
 *   (adaptive codebook excitation)                                  *
 *-------------------------------------------------------------------*/
void Pred_lt_3(
  short   exc[],       /* in/out: excitation buffer */
  short   T0,          /* input : integer pitch lag */
  short   frac,        /* input : fraction of lag   */
  short   L_subfr      /* input : subframe size     */
)
{
  short   i, j, k;
  short   *x0, *x1, *x2, *c1, *c2;
  int  s;

  x0 = &exc[-T0];

  frac = negate(frac);
  if (frac < 0)
  {
    frac = add(frac, UP_SAMP);
    x0--;
  }

  for (j=0; j<L_subfr; j++)
  {
    x1 = x0++;
    x2 = x0;
    c1 = &inter_3l[frac];
    c2 = &inter_3l[sub(UP_SAMP,frac)];

    s = 0;
    for(i=0, k=0; i< L_INTER10; i++, k+=UP_SAMP)
    {
      s = L_mac(s, x1[-i], c1[k]);
      s = L_mac(s, x2[i],  c2[k]);
    }

    exc[j] = round(s);
  }

  return;
}





/*---------------------------------------------------------------*
 *    Postfilter constant parameters (defined in "ld8a.h")       *
 *---------------------------------------------------------------*
 *   L_FRAME     : Frame size.                                   *
 *   L_SUBFR     : Sub-frame size.                               *
 *   M           : LPC order.                                    *
 *   MP1         : LPC order+1                                   *
 *   PIT_MAX     : Maximum pitch lag.                            *
 *   GAMMA2_PST  : Formant postfiltering factor (numerator)      *
 *   GAMMA1_PST  : Formant postfiltering factor (denominator)    *
 *   GAMMAP      : Harmonic postfiltering factor                 *
 *   MU          : Factor for tilt compensation filter           *
 *   AGC_FAC     : Factor for automatic gain control             *
 *---------------------------------------------------------------*/
/*------------------------------------------------------------*
 *   static vectors                                           *
 *------------------------------------------------------------*/

        /* inverse filtered synthesis (with A(z/GAMMA2_PST))   */


/*---------------------------------------------------------------*
 * Procedure    Init_Post_Filter:                                *
 *              ~~~~~~~~~~~~~~~~                                 *
 *  Initializes the postfilter parameters:                       *
 *---------------------------------------------------------------*/

void Init_Post_Filter(void)
{
  res2  = res2_buf + PIT_MAX;
  scal_res2  = scal_res2_buf + PIT_MAX;

  Set_zero(mem_syn_pst, M);
  Set_zero(res2_buf, PIT_MAX+L_SUBFR);
  Set_zero(scal_res2_buf, PIT_MAX+L_SUBFR);

  return;
}




/*------------------------------------------------------------------------*
 *  Procedure     Post_Filter:                                            *
 *                ~~~~~~~~~~~                                             *
 *------------------------------------------------------------------------*
 *  The postfiltering process is described as follows:                    *
 *                                                                        *
 *  - inverse filtering of syn[] through A(z/GAMMA2_PST) to get res2[]    *
 *  - use res2[] to compute pitch parameters                              *
 *  - perform pitch postfiltering                                         *
 *  - tilt compensation filtering; 1 - MU*k*z^-1                          *
 *  - synthesis filtering through 1/A(z/GAMMA1_PST)                       *
 *  - adaptive gain control                                               *
 *------------------------------------------------------------------------*/



void Post_Filter(
  short *syn,       /* in/out: synthesis speech (postfiltered is output)    */
  short *Az_4,      /* input : interpolated LPC parameters in all subframes */
  short *T          /* input : decoded pitch lags in all subframes          */
)
{
 /*-------------------------------------------------------------------*
  *           Declaration of parameters                               *
  *-------------------------------------------------------------------*/

 short res2_pst[L_SUBFR];  /* res2[] after pitch postfiltering */
 short syn_pst[L_FRAME];   /* post filtered synthesis speech   */

 short Ap3[MP1], Ap4[MP1];  /* bandwidth expanded LP parameters */

 short *Az;                 /* pointer to Az_4:                 */
                             /*  LPC parameters in each subframe */
 short   t0_max, t0_min;    /* closed-loop pitch search range   */
 short   i_subfr;           /* index for beginning of subframe  */

 short h[L_H];

 short  i, j;
 short  temp1, temp2;
 int  L_tmp;

   /*-----------------------------------------------------*
    * Post filtering                                      *
    *-----------------------------------------------------*/

    Az = Az_4;

    for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
    {
      /* Find pitch range t0_min - t0_max */

      t0_min = sub(*T++, 3);
      t0_max = add(t0_min, 6);
      if (sub(t0_max, PIT_MAX) > 0) {
        t0_max = PIT_MAX;
        t0_min = sub(t0_max, 6);
      }

      /* Find weighted filter coefficients Ap3[] and ap[4] */

      Weight_Az(Az, GAMMA2_PST, M, Ap3);
      Weight_Az(Az, GAMMA1_PST, M, Ap4);

      /* filtering of synthesis speech by A(z/GAMMA2_PST) to find res2[] */

      Residu(Ap3, &syn[i_subfr], res2, L_SUBFR);

      /* scaling of "res2[]" to avoid energy overflow */

      for (j=0; j<L_SUBFR; j++)
      {
        scal_res2[j] = shr(res2[j], 2);
      }

      /* pitch postfiltering */

      pit_pst_filt(res2, scal_res2, t0_min, t0_max, L_SUBFR, res2_pst);

      /* tilt compensation filter */

      /* impulse response of A(z/GAMMA2_PST)/A(z/GAMMA1_PST) */

      Copy(Ap3, h, M+1);
      Set_zero(&h[M+1], L_H-M-1);
      Syn_filt(Ap4, h, h, L_H, &h[M+1], 0);

      /* 1st correlation of h[] */

      L_tmp = L_mult(h[0], h[0]);
      for (i=1; i<L_H; i++) L_tmp = L_mac(L_tmp, h[i], h[i]);
      temp1 = extract_h(L_tmp);

      L_tmp = L_mult(h[0], h[1]);
      for (i=1; i<L_H-1; i++) L_tmp = L_mac(L_tmp, h[i], h[i+1]);
      temp2 = extract_h(L_tmp);

      if(temp2 <= 0) {
        temp2 = 0;
      }
      else {
        temp2 = mult(temp2, MU);
        temp2 = div_s(temp2, temp1);
      }

      preemphasis(res2_pst, temp2, L_SUBFR);

      /* filtering through  1/A(z/GAMMA1_PST) */

      Syn_filt(Ap4, res2_pst, &syn_pst[i_subfr], L_SUBFR, mem_syn_pst, 1);

      /* scale output to input */

      agc(&syn[i_subfr], &syn_pst[i_subfr], L_SUBFR);

      /* update res2[] buffer;  shift by L_SUBFR */

      Copy(&res2[L_SUBFR-PIT_MAX], &res2[-PIT_MAX], PIT_MAX);
      Copy(&scal_res2[L_SUBFR-PIT_MAX], &scal_res2[-PIT_MAX], PIT_MAX);

      Az += MP1;
    }

    /* update syn[] buffer */

    Copy(&syn[L_FRAME-M], &syn[-M], M);

    /* overwrite synthesis speech by postfiltered synthesis speech */

    Copy(syn_pst, syn, L_FRAME);

    return;
}




/*---------------------------------------------------------------------------*
 * procedure pitch_pst_filt                                                  *
 * ~~~~~~~~~~~~~~~~~~~~~~~~                                                  *
 * Find the pitch period  around the transmitted pitch and perform           *
 * harmonic postfiltering.                                                   *
 * Filtering through   (1 + g z^-T) / (1+g) ;   g = min(pit_gain*gammap, 1)  *
 *--------------------------------------------------------------------------*/

void pit_pst_filt(
  short *signal,      /* (i)     : input signal                        */
  short *scal_sig,    /* (i)     : input signal (scaled, divided by 4) */
  short t0_min,       /* (i)     : minimum value in the searched range */
  short t0_max,       /* (i)     : maximum value in the searched range */
  short L_subfr,      /* (i)     : size of filtering                   */
  short *signal_pst   /* (o)     : harmonically postfiltered signal    */
)
{
  short i, j, t0;
  short g0, gain, cmax, en, en0;
  short *p, *p1, *deb_sig;
  int corr, cor_max, ener, ener0, temp;
  int L_temp;

/*---------------------------------------------------------------------------*
 * Compute the correlations for all delays                                   *
 * and select the delay which maximizes the correlation                      *
 *---------------------------------------------------------------------------*/

  deb_sig = &scal_sig[-t0_min];
  cor_max = MIN_32;
  t0 = t0_min;             /* Only to remove warning from some compilers */
  for (i=t0_min; i<=t0_max; i++)
  {
    corr = 0;
    p    = scal_sig;
    p1   = deb_sig;
    for (j=0; j<L_subfr; j++)
       corr = L_mac(corr, *p++, *p1++);

    L_temp = L_sub(corr, cor_max);
    if (L_temp > (int)0)
    {
      cor_max = corr;
      t0 = i;
    }
    deb_sig--;
  }

  /* Compute the energy of the signal delayed by t0 */

  ener = 1;
  p = scal_sig - t0;
  for ( i=0; i<L_subfr ;i++, p++)
    ener = L_mac(ener, *p, *p);

  /* Compute the signal energy in the present subframe */

  ener0 = 1;
  p = scal_sig;
  for ( i=0; i<L_subfr; i++, p++)
    ener0 = L_mac(ener0, *p, *p);

  if (cor_max < 0)
  {
    cor_max = 0;
  }

  /* scale "cor_max", "ener" and "ener0" on 16 bits */

  temp = cor_max;
  if (ener > temp)
  {
    temp = ener;
  }
  if (ener0 > temp)
  {
    temp = ener0;
  }
  j = norm_l(temp);
  cmax = round(L_shl(cor_max, j));
  en = round(L_shl(ener, j));
  en0 = round(L_shl(ener0, j));

  /* prediction gain (dB)= -10 log(1-cor_max*cor_max/(ener*ener0)) */

  /* temp = (cor_max * cor_max) - (0.5 * ener * ener0)  */
  temp = L_mult(cmax, cmax);
  temp = L_sub(temp, L_shr(L_mult(en, en0), 1));

  if (temp < (int)0)           /* if prediction gain < 3 dB   */
  {                               /* switch off pitch postfilter */
    for (i = 0; i < L_subfr; i++)
      signal_pst[i] = signal[i];
    return;
  }

  if (sub(cmax, en) > 0)      /* if pitch gain > 1 */
  {
    g0 = INV_GAMMAP;
    gain = GAMMAP_2;
  }
  else {
    cmax = shr(mult(cmax, GAMMAP), 1);  /* cmax(Q14) = cmax(Q15) * GAMMAP */
    en = shr(en, 1);          /* Q14 */
    i = add(cmax, en);
    if(i > 0)
    {
      gain = div_s(cmax, i);    /* gain(Q15) = cor_max/(cor_max+ener)  */
      g0 = sub(32767, gain);    /* g0(Q15) = 1 - gain */
    }
    else
    {
      g0 =  32767;
      gain = 0;
    }
  }


  for (i = 0; i < L_subfr; i++)
  {
    /* signal_pst[i] = g0*signal[i] + gain*signal[i-t0]; */

    signal_pst[i] = add(mult(g0, signal[i]), mult(gain, signal[i-t0]));

  }

  return;
}


/*---------------------------------------------------------------------*
 * routine preemphasis()                                               *
 * ~~~~~~~~~~~~~~~~~~~~~                                               *
 * Preemphasis: filtering through 1 - g z^-1                           *
 *---------------------------------------------------------------------*/

void preemphasis(
  short *signal,  /* (i/o)   : input signal overwritten by the output */
  short g,        /* (i) Q15 : preemphasis coefficient                */
  short L         /* (i)     : size of filtering                      */
)
{
  static short mem_pre = 0;
  short *p1, *p2, temp, i;

  p1 = signal + L - 1;
  p2 = p1 - 1;
  temp = *p1;

  for (i = 0; i <= L-2; i++)
  {
    *p1-- = sub(*p1, mult(g, *p2--));
  }

  *p1 = sub(*p1, mult(g, mem_pre));

  mem_pre = temp;

  return;
}



/*----------------------------------------------------------------------*
 *   routine agc()                                                      *
 *   ~~~~~~~~~~~~~                                                      *
 * Scale the postfilter output on a subframe basis by automatic control *
 * of the subframe gain.                                                *
 *  gain[n] = AGC_FAC * gain[n-1] + (1 - AGC_FAC) g_in/g_out            *
 *----------------------------------------------------------------------*/

void agc(
  short *sig_in,   /* (i)     : postfilter input signal  */
  short *sig_out,  /* (i/o)   : postfilter output signal */
  short l_trm      /* (i)     : subframe size            */
)
{
  static short past_gain=4096;         /* past_gain = 1.0 (Q12) */
  short i, exp;
  short gain_in, gain_out, g0, gain;                     /* Q12 */
  int s;

  short signal[L_SUBFR];

  /* calculate gain_out with exponent */

  for(i=0; i<l_trm; i++)
    signal[i] = shr(sig_out[i], 2);

  s = 0;
  for(i=0; i<l_trm; i++)
    s = L_mac(s, signal[i], signal[i]);

  if (s == 0) {
    past_gain = 0;
    return;
  }
  exp = sub(norm_l(s), 1);
  gain_out = round(L_shl(s, exp));

  /* calculate gain_in with exponent */

  for(i=0; i<l_trm; i++)
    signal[i] = shr(sig_in[i], 2);

  s = 0;
  for(i=0; i<l_trm; i++)
    s = L_mac(s, signal[i], signal[i]);

  if (s == 0) {
    g0 = 0;
  }
  else {
    i = norm_l(s);
    gain_in = round(L_shl(s, i));
    exp = sub(exp, i);

   /*---------------------------------------------------*
    *  g0(Q12) = (1-AGC_FAC) * sqrt(gain_in/gain_out);  *
    *---------------------------------------------------*/

    s = L_deposit_l(div_s(gain_out,gain_in));   /* Q15 */
    s = L_shl(s, 7);           /* s(Q22) = gain_out / gain_in */
    s = L_shr(s, exp);         /* Q22, add exponent */

    /* i(Q12) = s(Q19) = 1 / sqrt(s(Q22)) */
    s = Inv_sqrt(s);           /* Q19 */
    i = round(L_shl(s,9));     /* Q12 */

    /* g0(Q12) = i(Q12) * (1-AGC_FAC)(Q15) */
    g0 = mult(i, AGC_FAC1);       /* Q12 */
  }

  /* compute gain(n) = AGC_FAC gain(n-1) + (1-AGC_FAC)gain_in/gain_out */
  /* sig_out(n) = gain(n) sig_out(n)                                   */

  gain = past_gain;
  for(i=0; i<l_trm; i++) {
    gain = mult(gain, AGC_FAC);
    gain = add(gain, g0);
    sig_out[i] = extract_h(L_shl(L_mult(sig_out[i], gain), 3));
  }
  past_gain = gain;

  return;
}





/*------------------------------------------------------------------------*
 * 2nd order high pass filter with cut off frequency at 100 Hz.           *
 * Designed with SPPACK efi command -40 dB att, 0.25 ri.                  *
 *                                                                        *
 * Algorithm:                                                             *
 *                                                                        *
 *  y[i] = b[0]*x[i]   + b[1]*x[i-1]   + b[2]*x[i-2]                      *
 *                     + a[1]*y[i-1]   + a[2]*y[i-2];                     *
 *                                                                        *
 *     b[3] = {0.93980581E+00, -0.18795834E+01, 0.93980581E+00};          *
 *     a[3] = {0.10000000E+01, 0.19330735E+01, -0.93589199E+00};          *
 *-----------------------------------------------------------------------*/

/* Static values to be preserved between calls */
/* y[] values is keep in double precision      */


/* Initialization of static values */

void Init_Post_Process(void)
{
  y2_hi = 0;
  y2_lo = 0;
  y1_hi = 0;
  y1_lo = 0;
  x0   = 0;
  x1   = 0;
}


void Post_Process(
  short signal[],    /* input/output signal */
  short lg)          /* length of signal    */
{
  short i, x2;
  int L_tmp;

  for(i=0; i<lg; i++)
  {
     x2 = x1;
     x1 = x0;
     x0 = signal[i];

     /*  y[i] = b[0]*x[i]   + b[1]*x[i-1]   + b[2]*x[i-2]    */
     /*                     + a[1]*y[i-1] + a[2] * y[i-2];      */

     L_tmp     = Mpy_32_16(y1_hi, y1_lo, a100[1]);
     L_tmp     = L_add(L_tmp, Mpy_32_16(y2_hi, y2_lo, a100[2]));
     L_tmp     = L_mac(L_tmp, x0, b100[0]);
     L_tmp     = L_mac(L_tmp, x1, b100[1]);
     L_tmp     = L_mac(L_tmp, x2, b100[2]);
     L_tmp     = L_shl(L_tmp, 2);      /* Q29 --> Q31 (Q13 --> Q15) */

     /* Multiplication by two of output speech with saturation. */
     signal[i] = round(L_shl(L_tmp, 1));

     y2_hi = y1_hi;
     y2_lo = y1_lo;
     L_Extract(L_tmp, &y1_hi, &y1_lo);
  }
  return;
}




short Parity_Pitch(    /* output: parity bit (XOR of 6 MSB bits)    */
   short pitch_index   /* input : index for which parity to compute */
)
{
  short temp, sum, i, bit;

  temp = shr(pitch_index, 1);

  sum = 1;
  for (i = 0; i <= 5; i++) {
    temp = shr(temp, 1);
    bit = temp & (short)1;
    sum = add(sum, bit);
  }
  sum = sum & (short)1;


  return sum;
}

/*--------------------------------------------------------------------*
 * check_parity_pitch - check parity of index with transmitted parity *
 *--------------------------------------------------------------------*/

short  Check_Parity_Pitch( /* output: 0 = no error, 1= error */
  short pitch_index,       /* input : index of parameter     */
  short parity             /* input : parity bit             */
)
{
  short temp, sum, i, bit;

  temp = shr(pitch_index, 1);

  sum = 1;
  for (i = 0; i <= 5; i++) {
    temp = shr(temp, 1);
    bit = temp & (short)1;
    sum = add(sum, bit);
  }
  sum = add(sum, parity);
  sum = sum & (short)1;

  return sum;
}



/*___________________________________________________________________________
 |                                                                           |
 |  This file contains operations in double precision.                       |
 |  These operations are not standard double precision operations.           |
 |  They are used where single precision is not enough but the full 32 bits  |
 |  precision is not necessary. For example, the function Div_32() has a     |
 |  24 bits precision which is enough for our purposes.                      |
 |                                                                           |
 |  The double precision numbers use a special representation:               |
 |                                                                           |
 |     L_32 = hi<<16 + lo<<1                                                 |
 |                                                                           |
 |  L_32 is a 32 bit integer.                                                |
 |  hi and lo are 16 bit signed integers.                                    |
 |  As the low part also contains the sign, this allows fast multiplication. |
 |                                                                           |
 |      0x8000 0000 <= L_32 <= 0x7fff fffe.                                  |
 |                                                                           |
 |  We will use DPF (Double Precision Format )in this file to specify        |
 |  this special format.                                                     |
 |___________________________________________________________________________|
*/

/*___________________________________________________________________________
 |                                                                           |
 |  Function L_Extract()                                                     |
 |                                                                           |
 |  Extract from a 32 bit integer two 16 bit DPF.                            |
 |                                                                           |
 |  Arguments:                                                               |
 |                                                                           |
 |   L_32      : 32 bit integer.                                             |
 |               0x8000 0000 <= L_32 <= 0x7fff ffff.                         |
 |   hi        : b16 to b31 of L_32                                          |
 |   lo        : (L_32 - hi<<16)>>1                                          |
 |___________________________________________________________________________|
*/

void L_Extract(int L_32, short *hi, short *lo)
{
  *hi  = extract_h(L_32);
  *lo  = extract_l( L_msu( L_shr(L_32, 1) , *hi, 16384));  /* lo = L_32>>1   */
  return;
}

/*___________________________________________________________________________
 |                                                                           |
 |  Function L_Comp()                                                        |
 |                                                                           |
 |  Compose from two 16 bit DPF a 32 bit integer.                            |
 |                                                                           |
 |     L_32 = hi<<16 + lo<<1                                                 |
 |                                                                           |
 |  Arguments:                                                               |
 |                                                                           |
 |   hi        msb                                                           |
 |   lo        lsf (with sign)                                               |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_32 <= 0x7fff fff0.                   |
 |                                                                           |
 |___________________________________________________________________________|
*/

int L_Comp(short hi, short lo)
{
  int L_32;

  L_32 = L_deposit_h(hi);
  return( L_mac(L_32, lo, 1));          /* = hi<<16 + lo<<1 */
}

/*___________________________________________________________________________
 | Function Mpy_32()                                                         |
 |                                                                           |
 |   Multiply two 32 bit integers (DPF). The result is divided by 2**31      |
 |                                                                           |
 |   L_32 = (hi1*hi2)<<1 + ( (hi1*lo2)>>15 + (lo1*hi2)>>15 )<<1              |
 |                                                                           |
 |   This operation can also be viewed as the multiplication of two Q31      |
 |   number and the result is also in Q31.                                   |
 |                                                                           |
 | Arguments:                                                                |
 |                                                                           |
 |  hi1         hi part of first number                                      |
 |  lo1         lo part of first number                                      |
 |  hi2         hi part of second number                                     |
 |  lo2         lo part of second number                                     |
 |                                                                           |
 |___________________________________________________________________________|
*/

int Mpy_32(short hi1, short lo1, short hi2, short lo2)
{
  int L_32;

  L_32 = L_mult(hi1, hi2);
  L_32 = L_mac(L_32, mult(hi1, lo2) , 1);
  L_32 = L_mac(L_32, mult(lo1, hi2) , 1);

  return( L_32 );
}

/*___________________________________________________________________________
 | Function Mpy_32_16()                                                      |
 |                                                                           |
 |   Multiply a 16 bit integer by a 32 bit (DPF). The result is divided      |
 |   by 2**15                                                                |
 |                                                                           |
 |   This operation can also be viewed as the multiplication of a Q31        |
 |   number by a Q15 number, the result is in Q31.                           |
 |                                                                           |
 |   L_32 = (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1                                |
 |                                                                           |
 | Arguments:                                                                |
 |                                                                           |
 |  hi          hi part of 32 bit number.                                    |
 |  lo          lo part of 32 bit number.                                    |
 |  n           16 bit number.                                               |
 |                                                                           |
 |___________________________________________________________________________|
*/

int Mpy_32_16(short hi, short lo, short n)
{
  int L_32;

  L_32 = L_mult(hi, n);
  L_32 = L_mac(L_32, mult(lo, n) , 1);

  return( L_32 );
}

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : Div_32                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |             Fractional integer division of two 32 bit numbers.            |
 |             L_num / L_denom.                                              |
 |             L_num and L_denom must be positive and L_num < L_denom.       |
 |             L_denom = denom_hi<<16 + denom_lo<<1                          |
 |             denom_hi is a normalize number.                               |
 |             The result is in Q30.                                         |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_num                                                                  |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x0000 0000 < L_num < L_denom                         |
 |                                                                           |
 |    L_denom = denom_hi<<16 + denom_lo<<1      (DPF)                        |
 |                                                                           |
 |       denom_hi                                                            |
 |             16 bit positive normalized integer whose value falls in the   |
 |             range : 0x4000 < hi < 0x7fff                                  |
 |       denom_lo                                                            |
 |             16 bit positive integer whose value falls in the              |
 |             range : 0 < lo < 0x7fff                                       |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_div                                                                  |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x0000 0000 <= L_div <= 0x7fff ffff.                  |
 |             It's a Q31 value                                              |
 |                                                                           |
 |  Algorithm:                                                               |
 |                                                                           |
 |  - find = 1/L_denom.                                                      |
 |      First approximation: approx = 1 / denom_hi                           |
 |      1/L_denom = approx * (2.0 - L_denom * approx )                       |
 |                                                                           |
 |  -  result = L_num * (1/L_denom)                                          |
 |___________________________________________________________________________|
*/

int Div_32(int L_num, short denom_hi, short denom_lo)
{
  short approx, hi, lo, n_hi, n_lo;
  int L_32;


  /* First approximation: 1 / L_denom = 1/denom_hi */

  approx = div_s( (short)0x3fff, denom_hi);    /* result in Q14 */
                                                /* Note: 3fff = 0.5 in Q15 */

  /* 1/L_denom = approx * (2.0 - L_denom * approx) */

  L_32 = Mpy_32_16(denom_hi, denom_lo, approx); /* result in Q30 */


  L_32 = L_sub( (int)0x7fffffffL, L_32);      /* result in Q30 */

  L_Extract(L_32, &hi, &lo);

  L_32 = Mpy_32_16(hi, lo, approx);             /* = 1/L_denom in Q29 */

  /* L_num * (1/L_denom) */

  L_Extract(L_32, &hi, &lo);
  L_Extract(L_num, &n_hi, &n_lo);
  L_32 = Mpy_32(n_hi, n_lo, hi, lo);            /* result in Q29   */
  L_32 = L_shl(L_32, 2);                        /* From Q29 to Q31 */

  return( L_32 );
}





void Lsp_get_quant(
  short lspcb1[][M],      /* (i) Q13 : first stage LSP codebook      */
  short lspcb2[][M],      /* (i) Q13 : Second stage LSP codebook     */
  short code0,            /* (i)     : selected code of first stage  */
  short code1,            /* (i)     : selected code of second stage */
  short code2,            /* (i)     : selected code of second stage */
  short fg[][M],          /* (i) Q15 : MA prediction coef.           */
  short freq_prev[][M],   /* (i) Q13 : previous LSP vector           */
  short lspq[],           /* (o) Q13 : quantized LSP parameters      */
  short fg_sum[]          /* (i) Q15 : present MA prediction coef.   */
)
{
  short j;
  short buf[M];           /* Q13 */


  for ( j = 0 ; j < NC ; j++ )
    buf[j] = add( lspcb1[code0][j], lspcb2[code1][j] );

  for ( j = NC ; j < M ; j++ )
    buf[j] = add( lspcb1[code0][j], lspcb2[code2][j] );

  Lsp_expand_1_2(buf, GAP1);
  Lsp_expand_1_2(buf, GAP2);

  Lsp_prev_compose(buf, lspq, fg, freq_prev, fg_sum);

  Lsp_prev_update(buf, freq_prev);

  Lsp_stability( lspq );

  return;
}


void Lsp_expand_1(
  short buf[],        /* (i/o) Q13 : LSP vectors */
  short gap           /* (i)   Q13 : gap         */
)
{
  short j, tmp;
  short diff;        /* Q13 */

  for ( j = 1 ; j < NC ; j++ ) {
    diff = sub( buf[j-1], buf[j] );
    tmp = shr( add( diff, gap), 1 );

    if ( tmp >  0 ) {
      buf[j-1] = sub( buf[j-1], tmp );
      buf[j]   = add( buf[j], tmp );
    }
  }
  return;
}


void Lsp_expand_2(
  short buf[],       /* (i/o) Q13 : LSP vectors */
  short gap          /* (i)   Q13 : gap         */
)
{
  short j, tmp;
  short diff;        /* Q13 */

  for ( j = NC ; j < M ; j++ ) {
    diff = sub( buf[j-1], buf[j] );
    tmp = shr( add( diff, gap), 1 );

    if ( tmp > 0 ) {
      buf[j-1] = sub( buf[j-1], tmp );
      buf[j]   = add( buf[j], tmp );
    }
  }
  return;
}


void Lsp_expand_1_2(
  short buf[],       /* (i/o) Q13 : LSP vectors */
  short gap          /* (i)   Q13 : gap         */
)
{
  short j, tmp;
  short diff;        /* Q13 */

  for ( j = 1 ; j < M ; j++ ) {
    diff = sub( buf[j-1], buf[j] );
    tmp = shr( add( diff, gap), 1 );

    if ( tmp > 0 ) {
      buf[j-1] = sub( buf[j-1], tmp );
      buf[j]   = add( buf[j], tmp );
    }
  }
  return;
}


/*
  Functions which use previous LSP parameter (freq_prev).
*/


/*
  compose LSP parameter from elementary LSP with previous LSP.
*/
void Lsp_prev_compose(
  short lsp_ele[],             /* (i) Q13 : LSP vectors                 */
  short lsp[],                 /* (o) Q13 : quantized LSP parameters    */
  short fg[][M],               /* (i) Q15 : MA prediction coef.         */
  short freq_prev[][M],        /* (i) Q13 : previous LSP vector         */
  short fg_sum[]               /* (i) Q15 : present MA prediction coef. */
)
{
  short j, k;
  int L_acc;                 /* Q29 */

  for ( j = 0 ; j < M ; j++ ) {
    L_acc = L_mult( lsp_ele[j], fg_sum[j] );
    for ( k = 0 ; k < MA_NP ; k++ )
      L_acc = L_mac( L_acc, freq_prev[k][j], fg[k][j] );

    lsp[j] = extract_h(L_acc);
  }
  return;
}


/*
  extract elementary LSP from composed LSP with previous LSP
*/
void Lsp_prev_extract(
  short lsp[M],                /* (i) Q13 : unquantized LSP parameters  */
  short lsp_ele[M],            /* (o) Q13 : target vector               */
  short fg[MA_NP][M],          /* (i) Q15 : MA prediction coef.         */
  short freq_prev[MA_NP][M],   /* (i) Q13 : previous LSP vector         */
  short fg_sum_inv[M]          /* (i) Q12 : inverse previous LSP vector */
)
{
  short j, k;
  int L_temp;                /* Q19 */
  short temp;                  /* Q13 */


  for ( j = 0 ; j < M ; j++ ) {
    L_temp = L_deposit_h(lsp[j]);
    for ( k = 0 ; k < MA_NP ; k++ )
      L_temp = L_msu( L_temp, freq_prev[k][j], fg[k][j] );

    temp = extract_h(L_temp);
    L_temp = L_mult( temp, fg_sum_inv[j] );
    lsp_ele[j] = extract_h( L_shl( L_temp, 3 ) );

  }
  return;
}


/*
  update previous LSP parameter
*/
void Lsp_prev_update(
  short lsp_ele[M],             /* (i)   Q13 : LSP vectors           */
  short freq_prev[MA_NP][M]     /* (i/o) Q13 : previous LSP vectors  */
)
{
  short k;

  for ( k = MA_NP-1 ; k > 0 ; k-- )
    Copy(freq_prev[k-1], freq_prev[k], M);

  Copy(lsp_ele, freq_prev[0], M);
  return;
}

void Lsp_stability(
  short buf[]       /* (i/o) Q13 : quantized LSP parameters      */
)
{
  short j;
  short tmp;
  int L_diff;
  int L_acc, L_accb;

  for(j=0; j<M-1; j++) {
    L_acc = L_deposit_l( buf[j+1] );
    L_accb = L_deposit_l( buf[j] );
    L_diff = L_sub( L_acc, L_accb );

    if( L_diff < 0L ) {
      /* exchange buf[j]<->buf[j+1] */
      tmp      = buf[j+1];
      buf[j+1] = buf[j];
      buf[j]   = tmp;
    }
  }


  if( sub(buf[0], L_LIMIT) <0 ) {
    buf[0] = L_LIMIT;
    printf("lsp_stability warning Low \n");
  }
  for(j=0; j<M-1; j++) {
    L_acc = L_deposit_l( buf[j+1] );
    L_accb = L_deposit_l( buf[j] );
    L_diff = L_sub( L_acc, L_accb );

    if( L_sub(L_diff, GAP3)<0L ) {
      buf[j+1] = add( buf[j], GAP3 );
    }
  }

  if( sub(buf[M-1],M_LIMIT)>0 ) {
    buf[M-1] = M_LIMIT;
    printf("lsp_stability warning High \n");
  }
  return;
}




/*----------------------------------------------------------------------------
 * Lsp_decw_reset -   set the previous LSP vectors
 *----------------------------------------------------------------------------
 */
void Lsp_decw_reset(  void)
{
  short i;

  for(i=0; i<MA_NP; i++)
    Copy( &freq_prev_reset[0], &freq_prev[i][0], M );

  prev_ma = 0;

  Copy( freq_prev_reset, prev_lsp, M);
}



/*----------------------------------------------------------------------------
 * Lsp_iqua_cs -  LSP main quantization routine
 *----------------------------------------------------------------------------
 */
void Lsp_iqua_cs(
 short prm[],          /* (i)     : indexes of the selected LSP */
 short lsp_q[],        /* (o) Q13 : Quantized LSP parameters    */
 short erase           /* (i)     : frame erase information     */
)
{
  short mode_index;
  short code0;
  short code1;
  short code2;
  short buf[M];     /* Q13 */

  if( erase==0 ) {  /* Not frame erasure */
    mode_index = shr(prm[0] ,NC0_B) & (short)1;
    code0 = prm[0] & (short)(NC0 - 1);
    code1 = shr(prm[1] ,NC1_B) & (short)(NC1 - 1);
    code2 = prm[1] & (short)(NC1 - 1);

    /* compose quantized LSP (lsp_q) from indexes */

    Lsp_get_quant(lspcb1, lspcb2, code0, code1, code2,
      fg[mode_index], freq_prev, lsp_q, fg_sum[mode_index]);

    /* save parameters to use in case of the frame erased situation */

    Copy(lsp_q, prev_lsp, M);
    prev_ma = mode_index;
  }
  else {           /* Frame erased */
    /* use revious LSP */

    Copy(prev_lsp, lsp_q, M);

    /* update freq_prev */

    Lsp_prev_extract(prev_lsp, buf,
      fg[prev_ma], freq_prev, fg_sum_inv[prev_ma]);
    Lsp_prev_update(buf, freq_prev);
  }

  return;
}



/*-------------------------------------------------------------------*
 * Function  D_lsp:                                                  *
 *           ~~~~~~                                                  *
 *-------------------------------------------------------------------*/

void D_lsp(
  short prm[],          /* (i)     : indexes of the selected LSP */
  short lsp_q[],        /* (o) Q15 : Quantized LSP parameters    */
  short erase           /* (i)     : frame erase information     */
)
{
  short lsf_q[M];       /* domain 0.0<= lsf_q <PI in Q13 */


  Lsp_iqua_cs(prm, lsf_q, erase);

  /* Convert LSFs to LSPs */

  Lsf_lsp2(lsf_q, lsp_q, M);

  return;
}




static void Get_lsp_pol(short *lsp, int *f);

void Lsp_Az(
  short lsp[],    /* (i) Q15 : line spectral frequencies            */
  short a[]       /* (o) Q12 : predictor coefficients (order = 10)  */
)
{
  short i, j;
  int f1[6], f2[6];
  int t0;

  Get_lsp_pol(&lsp[0],f1);
  Get_lsp_pol(&lsp[1],f2);

  for (i = 5; i > 0; i--)
  {
    f1[i] = L_add(f1[i], f1[i-1]);        /* f1[i] += f1[i-1]; */
    f2[i] = L_sub(f2[i], f2[i-1]);        /* f2[i] -= f2[i-1]; */
  }

  a[0] = 4096;
  for (i = 1, j = 10; i <= 5; i++, j--)
  {
    t0   = L_add(f1[i], f2[i]);                 /* f1[i] + f2[i]             */
    a[i] = extract_l( L_shr_r(t0, 13) );        /* from Q24 to Q12 and * 0.5 */

    t0   = L_sub(f1[i], f2[i]);                 /* f1[i] - f2[i]             */
    a[j] = extract_l( L_shr_r(t0, 13) );        /* from Q24 to Q12 and * 0.5 */

  }

  return;
}

/*-----------------------------------------------------------*
 * procedure Get_lsp_pol:                                    *
 *           ~~~~~~~~~~~                                     *
 *   Find the polynomial F1(z) or F2(z) from the LSPs        *
 *-----------------------------------------------------------*
 *                                                           *
 * Parameters:                                               *
 *  lsp[]   : line spectral freq. (cosine domain)    in Q15  *
 *  f[]     : the coefficients of F1 or F2           in Q24  *
 *-----------------------------------------------------------*/

static void Get_lsp_pol(short *lsp, int *f)
{
  short i,j, hi, lo;
  int t0;

   /* All computation in Q24 */

   *f = L_mult(4096, 2048);             /* f[0] = 1.0;             in Q24  */
   f++;
   *f = L_msu((int)0, *lsp, 512);    /* f[1] =  -2.0 * lsp[0];  in Q24  */

   f++;
   lsp += 2;                            /* Advance lsp pointer             */

   for(i=2; i<=5; i++)
   {
     *f = f[-2];

     for(j=1; j<i; j++, f--)
     {
       L_Extract(f[-1] ,&hi, &lo);
       t0 = Mpy_32_16(hi, lo, *lsp);         /* t0 = f[-1] * lsp    */
       t0 = L_shl(t0, 1);
       *f = L_add(*f, f[-2]);                /* *f += f[-2]         */
       *f = L_sub(*f, t0);                   /* *f -= t0            */
     }
     *f   = L_msu(*f, *lsp, 512);            /* *f -= lsp<<9        */
     f   += i;                               /* Advance f pointer   */
     lsp += 2;                               /* Advance lsp pointer */
   }

   return;
}

/*___________________________________________________________________________
 |                                                                           |
 |   Functions : Lsp_lsf and Lsf_lsp                                         |
 |                                                                           |
 |      Lsp_lsf   Transformation lsp to lsf                                  |
 |      Lsf_lsp   Transformation lsf to lsp                                  |
 |---------------------------------------------------------------------------|
 |  Algorithm:                                                               |
 |                                                                           |
 |   The transformation from lsp[i] to lsf[i] and lsf[i] to lsp[i] are       |
 |   approximated by a look-up table and interpolation.                      |
 |___________________________________________________________________________|
*/


void Lsf_lsp(
  short lsf[],    /* (i) Q15 : lsf[m] normalized (range: 0.0<=val<=0.5) */
  short lsp[],    /* (o) Q15 : lsp[m] (range: -1<=val<1)                */
  short m         /* (i)     : LPC order                                */
)
{
  short i, ind, offset;
  int L_tmp;

  for(i=0; i<m; i++)
  {
    ind    = shr(lsf[i], 8);               /* ind    = b8-b15 of lsf[i] */
    offset = lsf[i] & (short)0x00ff;      /* offset = b0-b7  of lsf[i] */

    /* lsp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 256 */

    L_tmp   = L_mult(sub(table[ind+1], table[ind]), offset);
    lsp[i] = add(table[ind], extract_l(L_shr(L_tmp, 9)));
  }
  return;
}


void Lsp_lsf(
  short lsp[],    /* (i) Q15 : lsp[m] (range: -1<=val<1)                */
  short lsf[],    /* (o) Q15 : lsf[m] normalized (range: 0.0<=val<=0.5) */
  short m         /* (i)     : LPC order                                */
)
{
  short i, ind, tmp;
  int L_tmp;

  ind = 63;    /* begin at end of table -1 */

  for(i= m-(short)1; i >= 0; i--)
  {
    /* find value in table that is just greater than lsp[i] */
    while( sub(table[ind], lsp[i]) < 0 )
    {
      ind = sub(ind,1);
    }

    /* acos(lsp[i])= ind*256 + ( ( lsp[i]-table[ind] ) * slope[ind] )/4096 */

    L_tmp  = L_mult( sub(lsp[i], table[ind]) , slope[ind] );
    tmp = round(L_shl(L_tmp, 3));     /*(lsp[i]-table[ind])*slope[ind])>>12*/
    lsf[i] = add(tmp, shl(ind, 8));
  }
  return;
}

/*___________________________________________________________________________
 |                                                                           |
 |   Functions : Lsp_lsf and Lsf_lsp                                         |
 |                                                                           |
 |      Lsp_lsf   Transformation lsp to lsf                                  |
 |      Lsf_lsp   Transformation lsf to lsp                                  |
 |---------------------------------------------------------------------------|
 |  Algorithm:                                                               |
 |                                                                           |
 |   The transformation from lsp[i] to lsf[i] and lsf[i] to lsp[i] are       |
 |   approximated by a look-up table and interpolation.                      |
 |___________________________________________________________________________|
*/

void Lsf_lsp2(
  short lsf[],    /* (i) Q13 : lsf[m] (range: 0.0<=val<PI) */
  short lsp[],    /* (o) Q15 : lsp[m] (range: -1<=val<1)   */
  short m         /* (i)     : LPC order                   */
)
{
  short i, ind;
  short offset;   /* in Q8 */
  short freq;     /* normalized frequency in Q15 */
  int L_tmp;

  for(i=0; i<m; i++)
  {
/*    freq = abs_s(freq);*/
    freq = mult(lsf[i], 20861);          /* 20861: 1.0/(2.0*PI) in Q17 */
    ind    = shr(freq, 8);               /* ind    = b8-b15 of freq */
    offset = freq & (short)0x00ff;      /* offset = b0-b7  of freq */

    if ( sub(ind, 63)>0 ){
      ind = 63;                 /* 0 <= ind <= 63 */
    }

    /* lsp[i] = table2[ind]+ (slope_cos[ind]*offset >> 12) */

    L_tmp   = L_mult(slope_cos[ind], offset);   /* L_tmp in Q28 */
    lsp[i] = add(table2[ind], extract_l(L_shr(L_tmp, 13)));

  }
  return;
}



void Lsp_lsf2(
  short lsp[],    /* (i) Q15 : lsp[m] (range: -1<=val<1)   */
  short lsf[],    /* (o) Q13 : lsf[m] (range: 0.0<=val<PI) */
  short m         /* (i)     : LPC order                   */
)
{
  short i, ind;
  short offset;   /* in Q15 */
  short freq;     /* normalized frequency in Q16 */
  int L_tmp;

  ind = 63;           /* begin at end of table2 -1 */

  for(i= m-(short)1; i >= 0; i--)
  {
    /* find value in table2 that is just greater than lsp[i] */
    while( sub(table2[ind], lsp[i]) < 0 )
    {
      ind = sub(ind,1);
      if ( ind <= 0 )
        break;
    }

    offset = sub(lsp[i], table2[ind]);

    /* acos(lsp[i])= ind*512 + (slope_acos[ind]*offset >> 11) */

    L_tmp  = L_mult( slope_acos[ind], offset );   /* L_tmp in Q28 */
    freq = add(shl(ind, 9), extract_l(L_shr(L_tmp, 12)));
    lsf[i] = mult(freq, 25736);           /* 25736: 2.0*PI in Q12 */

  }
  return;
}

/*-------------------------------------------------------------*
 *  procedure Weight_Az                                        *
 *            ~~~~~~~~~                                        *
 * Weighting of LPC coefficients.                              *
 *   ap[i]  =  a[i] * (gamma ** i)                             *
 *                                                             *
 *-------------------------------------------------------------*/


void Weight_Az(
  short a[],      /* (i) Q12 : a[m+1]  LPC coefficients             */
  short gamma,    /* (i) Q15 : Spectral expansion factor.           */
  short m,        /* (i)     : LPC order.                           */
  short ap[]      /* (o) Q12 : Spectral expanded LPC coefficients   */
)
{
  short i, fac;

  ap[0] = a[0];
  fac   = gamma;
  for(i=1; i<m; i++)
  {
    ap[i] = round( L_mult(a[i], fac) );
    fac   = round( L_mult(fac, gamma) );
  }
  ap[m] = round( L_mult(a[m], fac) );

  return;
}

/*----------------------------------------------------------------------*
 * Function Int_qlpc()                                                  *
 * ~~~~~~~~~~~~~~~~~~~                                                  *
 * Interpolation of the LPC parameters.                                 *
 *----------------------------------------------------------------------*/

/* Interpolation of the quantized LSP's */

void Int_qlpc(
 short lsp_old[], /* input : LSP vector of past frame              */
 short lsp_new[], /* input : LSP vector of present frame           */
 short Az[]       /* output: interpolated Az() for the 2 subframes */
)
{
  short i;
  short lsp[M];

  /*  lsp[i] = lsp_new[i] * 0.5 + lsp_old[i] * 0.5 */

  for (i = 0; i < M; i++) {
    lsp[i] = add(shr(lsp_new[i], 1), shr(lsp_old[i], 1));
  }

  Lsp_Az(lsp, Az);              /* Subframe 1 */

  Lsp_Az(lsp_new, &Az[MP1]);    /* Subframe 2 */

  return;
}


/*---------------------------------------------------------------------------*
 * Function  Gain_predict                                                    *
 * ~~~~~~~~~~~~~~~~~~~~~~                                                    *
 * MA prediction is performed on the innovation energy (in dB with mean      *
 * removed).                                                                 *
 *---------------------------------------------------------------------------*/
void Gain_predict(
   short past_qua_en[], /* (i) Q10 :Past quantized energies        */
   short code[],        /* (i) Q13 :Innovative vector.             */
   short L_subfr,       /* (i)     :Subframe length.               */
   short *gcode0,       /* (o) Qxx :Predicted codebook gain        */
   short *exp_gcode0    /* (o)     :Q-Format(gcode0)               */
)
{
   short  i, exp, frac;
   int  L_tmp;

  /*-------------------------------*
   * Energy coming from code       *
   *-------------------------------*/

   L_tmp = 0;
   for(i=0; i<L_subfr; i++)
     L_tmp = L_mac(L_tmp, code[i], code[i]);

  /*-----------------------------------------------------------------*
   *  Compute: means_ener - 10log10(ener_code/ L_sufr)               *
   *  Note: mean_ener change from 36 dB to 30 dB because input/2     *
   *                                                                 *
   * = 30.0 - 10 log10( ener_code / lcode)  + 10log10(2^27)          *
   *                                          !!ener_code in Q27!!   *
   * = 30.0 - 3.0103 * log2(ener_code) + 10log10(40) + 10log10(2^27) *
   * = 30.0 - 3.0103 * log2(ener_code) + 16.02  + 81.278             *
   * = 127.298 - 3.0103 * log2(ener_code)                            *
   *-----------------------------------------------------------------*/

   Log2(L_tmp, &exp, &frac);               /* Q27->Q0 ^Q0 ^Q15       */
   L_tmp = Mpy_32_16(exp, frac, -24660);   /* Q0 Q15 Q13 -> ^Q14     */
                                           /* hi:Q0+Q13+1            */
                                           /* lo:Q15+Q13-15+1        */
                                           /* -24660[Q13]=-3.0103    */
   L_tmp = L_mac(L_tmp, 32588, 32);        /* 32588*32[Q14]=127.298  */

  /*-----------------------------------------------------------------*
   * Compute gcode0.                                                 *
   *  = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + mean_ener    *
   *-----------------------------------------------------------------*/

   L_tmp = L_shl(L_tmp, 10);                      /* From Q14 to Q24 */
   for(i=0; i<4; i++)
     L_tmp = L_mac(L_tmp, pred[i], past_qua_en[i]); /* Q13*Q10 ->Q24 */

   *gcode0 = extract_h(L_tmp);                    /* From Q24 to Q8  */

  /*-----------------------------------------------------------------*
   * gcode0 = pow(10.0, gcode0/20)                                   *
   *        = pow(2, 3.3219*gcode0/20)                               *
   *        = pow(2, 0.166*gcode0)                                   *
   *-----------------------------------------------------------------*/

   L_tmp = L_mult(*gcode0, 5439);       /* *0.166 in Q15, result in Q24*/
   L_tmp = L_shr(L_tmp, 8);             /* From Q24 to Q16             */
   L_Extract(L_tmp, &exp, &frac);       /* Extract exponent of gcode0  */

   *gcode0 = extract_l(Pow2(14, frac)); /* Put 14 as exponent so that  */
                                        /* output of Pow2() will be:   */
                                        /* 16768 < Pow2() <= 32767     */
   *exp_gcode0 = sub(14,exp);
}


/*---------------------------------------------------------------------------*
 * Function  Gain_update                                                     *
 * ~~~~~~~~~~~~~~~~~~~~~~                                                    *
 * update table of past quantized energies                                   *
 *---------------------------------------------------------------------------*/
void Gain_update(
   short past_qua_en[],   /* (io) Q10 :Past quantized energies           */
   int  L_gbk12         /* (i) Q13 : gbk1[indice1][1]+gbk2[indice2][1] */
)
{
   short  i, tmp;
   short  exp, frac;
   int  L_acc;

   for(i=3; i>0; i--){
      past_qua_en[i] = past_qua_en[i-1];         /* Q10 */
   }
  /*----------------------------------------------------------------------*
   * -- past_qua_en[0] = 20*log10(gbk1[index1][1]+gbk2[index2][1]); --    *
   *    2 * 10 log10( gbk1[index1][1]+gbk2[index2][1] )                   *
   *  = 2 * 3.0103 log2( gbk1[index1][1]+gbk2[index2][1] )                *
   *  = 2 * 3.0103 log2( gbk1[index1][1]+gbk2[index2][1] )                *
   *                                                 24660:Q12(6.0205)    *
   *----------------------------------------------------------------------*/

   Log2( L_gbk12, &exp, &frac );               /* L_gbk12:Q13       */
   L_acc = L_Comp( sub(exp,13), frac);         /* L_acc:Q16           */
   tmp = extract_h( L_shl( L_acc,13 ) );       /* tmp:Q13           */
   past_qua_en[0] = mult( tmp, 24660 );        /* past_qua_en[]:Q10 */
}


/*---------------------------------------------------------------------------*
 * Function  Gain_update_erasure                                             *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                                             *
 * update table of past quantized energies (frame erasure)                   *
 *---------------------------------------------------------------------------*
 *     av_pred_en = 0.0;                                                     *
 *     for (i = 0; i < 4; i++)                                               *
 *        av_pred_en += past_qua_en[i];                                      *
 *     av_pred_en = av_pred_en*0.25 - 4.0;                                   *
 *     if (av_pred_en < -14.0) av_pred_en = -14.0;                           *
 *---------------------------------------------------------------------------*/
void Gain_update_erasure(
   short past_qua_en[]     /* (i) Q10 :Past quantized energies        */
)
{
   short  i, av_pred_en;
   int  L_tmp;

   L_tmp = 0;                                                     /* Q10 */
   for(i=0; i<4; i++)
      L_tmp = L_add( L_tmp, L_deposit_l( past_qua_en[i] ) );
   av_pred_en = extract_l( L_shr( L_tmp, 2 ) );
   av_pred_en = sub( av_pred_en, 4096 );                          /* Q10 */

   if( sub(av_pred_en, -14336) < 0 ){
      av_pred_en = -14336;                              /* 14336:14[Q10] */
   }

   for(i=3; i>0; i--){
      past_qua_en[i] = past_qua_en[i-1];
   }
   past_qua_en[0] = av_pred_en;
}





void Convolve(
  short x[],      /* (i)     : input vector                           */
  short h[],      /* (i) Q12 : impulse response                       */
  short y[],      /* (o)     : output vector                          */
  short L         /* (i)     : vector size                            */
)
{
   short i, n;
   int s;

   for (n = 0; n < L; n++)
   {
     s = 0;
     for (i = 0; i <= n; i++)
       s = L_mac(s, x[i], h[n-i]);

     s    = L_shl(s, 3);                   /* h is in Q12 and saturation */
     y[n] = extract_h(s);
   }

   return;
}

/*-----------------------------------------------------*
 * procedure Syn_filt:                                 *
 *           ~~~~~~~~                                  *
 * Do the synthesis filtering 1/A(z).                  *
 *-----------------------------------------------------*/


void Syn_filt(
  short a[],     /* (i) Q12 : a[m+1] prediction coefficients   (m=10)  */
  short x[],     /* (i)     : input signal                             */
  short y[],     /* (o)     : output signal                            */
  short lg,      /* (i)     : size of filtering                        */
  short mem[],   /* (i/o)   : memory associated with this filtering.   */
  short update   /* (i)     : 0=no update, 1=update of memory.         */
)
{
  short i, j;
  int s;
  short tmp[100];     /* This is usually done by memory allocation (lg+M) */
  short *yy;

  /* Copy mem[] to yy[] */

  yy = tmp;

  for(i=0; i<M; i++)
  {
    *yy++ = mem[i];
  }

  /* Do the filtering. */

  for (i = 0; i < lg; i++)
  {
    s = L_mult(x[i], a[0]);
    for (j = 1; j <= M; j++)
      s = L_msu(s, a[j], yy[-j]);

    s = L_shl(s, 3);
    *yy++ = round(s);
  }

  for(i=0; i<lg; i++)
  {
    y[i] = tmp[i+M];
  }

  /* Update of memory if update==1 */

  if(update != 0)
     for (i = 0; i < M; i++)
     {
       mem[i] = y[lg-M+i];
     }

 return;
}

/*-----------------------------------------------------------------------*
 * procedure Residu:                                                     *
 *           ~~~~~~                                                      *
 * Compute the LPC residual  by filtering the input speech through A(z)  *
 *-----------------------------------------------------------------------*/

void Residu(
  short a[],    /* (i) Q12 : prediction coefficients                     */
  short x[],    /* (i)     : speech (values x[-m..-1] are needed         */
  short y[],    /* (o)     : residual signal                             */
  short lg      /* (i)     : size of filtering                           */
)
{
  short i, j;
  int s;

  for (i = 0; i < lg; i++)
  {
    s = L_mult(x[i], a[0]);
    for (j = 1; j <= M; j++)
      s = L_mac(s, a[j], x[i-j]);

    s = L_shl(s, 3);
    y[i] = round(s);
  }
  return;
}



/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : Pow2()                                                  |
 |                                                                           |
 |     L_x = pow(2.0, exponent.fraction)                                     |
 |---------------------------------------------------------------------------|
 |  Algorithm:                                                               |
 |                                                                           |
 |   The function Pow2(L_x) is approximated by a table and linear            |
 |   interpolation.                                                          |
 |                                                                           |
 |   1- i = bit10-b15 of fraction,   0 <= i <= 31                            |
 |   2- a = bit0-b9   of fraction                                            |
 |   3- L_x = tabpow[i]<<16 - (tabpow[i] - tabpow[i+1]) * a * 2                 |
 |   4- L_x = L_x >> (30-exponent)     (with rounding)                       |
 |___________________________________________________________________________|
*/


int Pow2(        /* (o) Q0  : result       (range: 0<=val<=0x7fffffff) */
  short exponent,  /* (i) Q0  : Integer part.      (range: 0<=val<=30)   */
  short fraction   /* (i) Q15 : Fractional part.   (range: 0.0<=val<1.0) */
)
{
  short exp, i, a, tmp;
  int L_x;

  L_x = L_mult(fraction, 32);           /* L_x = fraction<<6           */
  i   = extract_h(L_x);                 /* Extract b10-b15 of fraction */
  L_x = L_shr(L_x, 1);
  a   = extract_l(L_x);                 /* Extract b0-b9   of fraction */
  a   = a & (short)0x7fff;

  L_x = L_deposit_h(tabpow[i]);         /* tabpow[i] << 16        */
  tmp = sub(tabpow[i], tabpow[i+1]);    /* tabpow[i] - tabpow[i+1] */
  L_x = L_msu(L_x, tmp, a);             /* L_x -= tmp*a*2        */

  exp = sub(30, exponent);
  L_x = L_shr_r(L_x, exp);

  return(L_x);
}

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : Log2()                                                  |
 |                                                                           |
 |       Compute log2(L_x).                                                  |
 |       L_x is positive.                                                    |
 |                                                                           |
 |       if L_x is negative or zero, result is 0.                            |
 |---------------------------------------------------------------------------|
 |  Algorithm:                                                               |
 |                                                                           |
 |   The function Log2(L_x) is approximated by a table and linear            |
 |   interpolation.                                                          |
 |                                                                           |
 |   1- Normalization of L_x.                                                |
 |   2- exponent = 30-exponent                                               |
 |   3- i = bit25-b31 of L_x,    32 <= i <= 63  ->because of normalization.  |
 |   4- a = bit10-b24                                                        |
 |   5- i -=32                                                               |
 |   6- fraction = tablog[i]<<16 - (tablog[i] - tablog[i+1]) * a * 2            |
 |___________________________________________________________________________|
*/

void Log2(
  int L_x,       /* (i) Q0 : input value                                 */
  short *exponent, /* (o) Q0 : Integer part of Log2.   (range: 0<=val<=30) */
  short *fraction  /* (o) Q15: Fractional  part of Log2. (range: 0<=val<1) */
)
{
  short exp, i, a, tmp;
  int L_y;

  if( L_x <= (int)0 )
  {
    *exponent = 0;
    *fraction = 0;
    return;
  }

  exp = norm_l(L_x);
  L_x = L_shl(L_x, exp );               /* L_x is normalized */

  *exponent = sub(30, exp);

  L_x = L_shr(L_x, 9);
  i   = extract_h(L_x);                 /* Extract b25-b31 */
  L_x = L_shr(L_x, 1);
  a   = extract_l(L_x);                 /* Extract b10-b24 of fraction */
  a   = a & (short)0x7fff;

  i   = sub(i, 32);

  L_y = L_deposit_h(tablog[i]);         /* tablog[i] << 16        */
  tmp = sub(tablog[i], tablog[i+1]);    /* tablog[i] - tablog[i+1] */
  L_y = L_msu(L_y, tmp, a);             /* L_y -= tmp*a*2        */

  *fraction = extract_h( L_y);

  return;
}

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : Inv_sqrt                                                |
 |                                                                           |
 |       Compute 1/sqrt(L_x).                                                |
 |       L_x is positive.                                                    |
 |                                                                           |
 |       if L_x is negative or zero, result is 1 (3fff ffff).                |
 |---------------------------------------------------------------------------|
 |  Algorithm:                                                               |
 |                                                                           |
 |   The function 1/sqrt(L_x) is approximated by a table and linear          |
 |   interpolation.                                                          |
 |                                                                           |
 |   1- Normalization of L_x.                                                |
 |   2- If (30-exponent) is even then shift right once.                      |
 |   3- exponent = (30-exponent)/2  +1                                       |
 |   4- i = bit25-b31 of L_x,    16 <= i <= 63  ->because of normalization.  |
 |   5- a = bit10-b24                                                        |
 |   6- i -=16                                                               |
 |   7- L_y = tabsqr[i]<<16 - (tabsqr[i] - tabsqr[i+1]) * a * 2                 |
 |   8- L_y >>= exponent                                                     |
 |___________________________________________________________________________|
*/


int Inv_sqrt(   /* (o) Q30 : output value   (range: 0<=val<1)           */
  int L_x       /* (i) Q0  : input value    (range: 0<=val<=7fffffff)   */
)
{
  short exp, i, a, tmp;
  int L_y;

  if( L_x <= (int)0) return ( (int)0x3fffffffL);

  exp = norm_l(L_x);
  L_x = L_shl(L_x, exp );               /* L_x is normalize */

  exp = sub(30, exp);
  if( (exp & 1) == 0 )                  /* If exponent even -> shift right */
      L_x = L_shr(L_x, 1);

  exp = shr(exp, 1);
  exp = add(exp, 1);

  L_x = L_shr(L_x, 9);
  i   = extract_h(L_x);                 /* Extract b25-b31 */
  L_x = L_shr(L_x, 1);
  a   = extract_l(L_x);                 /* Extract b10-b24 */
  a   = a & (short)0x7fff;

  i   = sub(i, 16);

  L_y = L_deposit_h(tabsqr[i]);         /* tabsqr[i] << 16          */
  tmp = sub(tabsqr[i], tabsqr[i+1]);    /* tabsqr[i] - tabsqr[i+1])  */
  L_y = L_msu(L_y, tmp, a);             /* L_y -=  tmp*a*2         */

  L_y = L_shr(L_y, exp);                /* denormalization */

  return(L_y);
}





 

///  Function Init_Decod_ld8a ->Initialization of variables for the decoder section.
void Init_Decod_ld8a(void)
{

  /* Initialize static pointer */

  exc = old_exc + PIT_MAX + L_INTERPOL;

  /* Static vectors to zero */

  Set_zero(old_exc, PIT_MAX+L_INTERPOL);
  Set_zero(mem_syn, M);

  sharp  = SHARPMIN;
  old_T0 = 60;
  gain_code = 0;
  gain_pitch = 0;

  Lsp_decw_reset();
 return;
}

/*-----------------------------------------------------------------*
 *   Function Decod_ld8a                                           *
 *           ~~~~~~~~~~                                            *
 *   ->Main decoder routine.                                       *
 *                                                                 *
 *-----------------------------------------------------------------*/

void Decod_ld8a(
  short  parm[],      /* (i)   : vector of synthesis parameters
                                  parm[0] = bad frame indicator (bfi)  */
  short  synth[],     /* (o)   : synthesis speech                     */
  short  A_t[],       /* (o)   : decoded LP filter in 2 subframes     */
  short  *T2          /* (o)   : decoded pitch lag in 2 subframes     */
)
{
  short  *Az;                  /* Pointer on A_t   */
  short  lsp_new[M];           /* LSPs             */
  short  code[L_SUBFR];        /* ACELP codevector */

  /* Scalars */

  short  i, j, i_subfr;
  short  T0, T0_frac, index;
  short  bfi;
  int  L_temp;

  short bad_pitch;             /* bad pitch indicator */
  extern short bad_lsf;        /* bad LSF indicator   */

  /* Test bad frame indicator (bfi) */

  bfi = *parm++;

  /* Decode the LSPs */

  D_lsp(parm, lsp_new, add(bfi, bad_lsf));
  parm += 2;

  /*
  Note: "bad_lsf" is introduce in case the standard is used with
         channel protection.
  */

  /* Interpolation of LPC for the 2 subframes */

  Int_qlpc(lsp_old, lsp_new, A_t);

  /* update the LSFs for the next frame */

  Copy(lsp_new, lsp_old, M);

/*------------------------------------------------------------------------*
 *          Loop for every subframe in the analysis frame                 *
 *------------------------------------------------------------------------*
 * The subframe size is L_SUBFR and the loop is repeated L_FRAME/L_SUBFR  *
 *  times                                                                 *
 *     - decode the pitch delay                                           *
 *     - decode algebraic code                                            *
 *     - decode pitch and codebook gains                                  *
 *     - find the excitation and compute synthesis speech                 *
 *------------------------------------------------------------------------*/

  Az = A_t;            /* pointer to interpolated LPC parameters */

  for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
  {

    index = *parm++;            /* pitch index */

    if(i_subfr == 0)
    {
      i = *parm++;              /* get parity check result */
      bad_pitch = add(bfi, i);
      if( bad_pitch == 0)
      {
        Dec_lag3(index, PIT_MIN, PIT_MAX, i_subfr, &T0, &T0_frac);
        old_T0 = T0;
      }
      else        /* Bad frame, or parity error */
      {
        T0  =  old_T0;
        T0_frac = 0;
        old_T0 = add( old_T0, 1);
        if( sub(old_T0, PIT_MAX) > 0) {
            old_T0 = PIT_MAX;
        }
      }
    }
    else                  /* second subframe */
    {
      if( bfi == 0)
      {
        Dec_lag3(index, PIT_MIN, PIT_MAX, i_subfr, &T0, &T0_frac);
        old_T0 = T0;
      }
      else
      {
        T0  =  old_T0;
        T0_frac = 0;
        old_T0 = add( old_T0, 1);
        if( sub(old_T0, PIT_MAX) > 0) {
            old_T0 = PIT_MAX;
        }
      }
    }
    *T2++ = T0;

   /*-------------------------------------------------*
    * - Find the adaptive codebook vector.            *
    *-------------------------------------------------*/

    Pred_lt_3(&exc[i_subfr], T0, T0_frac, L_SUBFR);

   /*-------------------------------------------------------*
    * - Decode innovative codebook.                         *
    * - Add the fixed-gain pitch contribution to code[].    *
    *-------------------------------------------------------*/

    if(bfi != 0)        /* Bad frame */
    {

      parm[0] = Random() & (short)0x1fff;     /* 13 bits random */
      parm[1] = Random() & (short)0x000f;     /*  4 bits random */
    }
    Decod_ACELP(parm[1], parm[0], code);
    parm +=2;

    j = shl(sharp, 1);          /* From Q14 to Q15 */
    if(sub(T0, L_SUBFR) <0 ) {
        for (i = T0; i < L_SUBFR; i++) {
          code[i] = add(code[i], mult(code[i-T0], j));
        }
    }

   /*-------------------------------------------------*
    * - Decode pitch and codebook gains.              *
    *-------------------------------------------------*/

    index = *parm++;      /* index of energy VQ */

    Dec_gain(index, code, L_SUBFR, bfi, &gain_pitch, &gain_code);

   /*-------------------------------------------------------------*
    * - Update pitch sharpening "sharp" with quantized gain_pitch *
    *-------------------------------------------------------------*/

    sharp = gain_pitch;
    if (sub(sharp, SHARPMAX) > 0) { sharp = SHARPMAX;  }
    if (sub(sharp, SHARPMIN) < 0) { sharp = SHARPMIN;  }

   /*-------------------------------------------------------*
    * - Find the total excitation.                          *
    * - Find synthesis speech corresponding to exc[].       *
    *-------------------------------------------------------*/

    for (i = 0; i < L_SUBFR;  i++)
    {
       /* exc[i] = gain_pitch*exc[i] + gain_code*code[i]; */
       /* exc[i]  in Q0   gain_pitch in Q14               */
       /* code[i] in Q13  gain_codeode in Q1              */

       L_temp = L_mult(exc[i+i_subfr], gain_pitch);
       L_temp = L_mac(L_temp, code[i], gain_code);
       L_temp = L_shl(L_temp, 1);
       exc[i+i_subfr] = round(L_temp);
    }

    Overflow = 0;
    Syn_filt(Az, &exc[i_subfr], &synth[i_subfr], L_SUBFR, mem_syn, 0);
    if(Overflow != 0)
    {
      /* In case of overflow in the synthesis          */
      /* -> Scale down vector exc[] and redo synthesis */

      for(i=0; i<PIT_MAX+L_INTERPOL+L_FRAME; i++)
        old_exc[i] = shr(old_exc[i], 2);

      Syn_filt(Az, &exc[i_subfr], &synth[i_subfr], L_SUBFR, mem_syn, 1);
    }
    else
      Copy(&synth[i_subfr+L_SUBFR-M], mem_syn, M);

    Az += MP1;    /* interpolated LPC parameters for next subframe */
  }

 /*--------------------------------------------------*
  * Update signal for next frame.                    *
  * -> shift to the left by L_FRAME  exc[]           *
  *--------------------------------------------------*/

  Copy(&old_exc[L_FRAME], &old_exc[0], PIT_MAX+L_INTERPOL);

  return;
}




/// (i)     : signs of 4 pulses. */ /* (i)     : Positions of the 4 pulses.*/ /* (o) Q13 : algebraic (fixed) codebook excitation    
void Decod_ACELP(  short sign,  short index,  short cod[])
{
	short i, j;
	short pos[4];
	/* Decode the positions */
	i      = index & (short)7;
	pos[0] = add(i, shl(i, 2));           /* pos0 =i*5 */
	
	index  = shr(index, 3);
	i      = index & (short)7;
	i      = add(i, shl(i, 2));           /* pos1 =i*5+1 */
	pos[1] = add(i, 1);
	index  = shr(index, 3);
	i      = index & (short)7;
	i      = add(i, shl(i, 2));           /* pos2 =i*5+1 */
	pos[2] = add(i, 2);
	index  = shr(index, 3);
	j      = index & (short)1;
	index  = shr(index, 1);
	i      = index & (short)7;
	i      = add(i, shl(i, 2));           /* pos3 =i*5+3+j */
	i      = add(i, 3);
	pos[3] = add(i, j);
	/* decode the signs  and build the codeword */

	for (i=0; i<L_SUBFR; i++) {    cod[i] = 0;  }
	for (j=0; j<4; j++)
	{
		i = sign & (short)1;    sign = shr(sign, 1);
		if (i != 0) {
			cod[pos[j]] = 8191;      /* Q13 +1.0 */
		}
		else {
			cod[pos[j]] = -8192;     /* Q13 -1.0 */
		}
	}
	return;
}


/* (i)     :Index of quantization.         */
/* (i) Q13 :Innovative vector.             */      /* (i)     :Subframe length.               */
          /* (i)     :Bad frame indicator            */
    /* (o) Q14 :Pitch gain.                    */
     /* (o) Q1  :Code gain.                     */
void Dec_gain(   short index,   short code[], short L_subfr, short bfi, short *gain_pit,   short *gain_cod)
{
	short  index1, index2, tmp;
	short  gcode0, exp_gcode0;
	int  L_gbk12, L_acc, L_accb;
	void    Gain_predict( short past_qua_en[], short code[], short L_subfr, short *gcode0, short *exp_gcode0 );
	void    Gain_update( short past_qua_en[], int L_gbk12 );
	void    Gain_update_erasure( short past_qua_en[] );
        /* Gain predictor, Past quantized energies = -14.0 in Q10 */

	static short past_qua_en[4] = { -14336, -14336, -14336, -14336 };	/*-------------- Case of erasure. ---------------*/
	if(bfi != 0){    *gain_pit = mult( *gain_pit, 29491 );      /* *0.9 in Q15 */
	     if (sub( *gain_pit, 29491) > 0) *gain_pit = 29491;
         *gain_cod = mult( *gain_cod, 32111 );      /* *0.98 in Q15 */
         ///update table of past quantized energies  (frame erasure) 
		 Gain_update_erasure(past_qua_en);
		 return;
	}
    /*-------------- Decode pitch gain ---------------*/
    index1 = imap1[ shr(index,NCODE2_B) ] ;
    index2 = imap2[ index & (NCODE2-1) ] ;
    *gain_pit = add( gbk1[index1][0], gbk2[index2][0] );
    /*-------------- Decode codebook gain ---------------*/
    /*---------------------------------------------------*
    *-  energy due to innovation                       -*
    *-  predicted energy                               -*
    *-  predicted codebook gain => gcode0[exp_gcode0]  -*
    *---------------------------------------------------*/
    Gain_predict( past_qua_en, code, L_subfr, &gcode0, &exp_gcode0 );
    /*-----------------------------------------------------------------*
    * *gain_code = (gbk1[indice1][1]+gbk2[indice2][1]) * gcode0;      *
    *-----------------------------------------------------------------*/
    L_acc = L_deposit_l( gbk1[index1][1] );
    L_accb = L_deposit_l( gbk2[index2][1] );
    L_gbk12 = L_add( L_acc, L_accb );                       /* Q13 */
    tmp = extract_l( L_shr( L_gbk12,1 ) );                  /* Q12 */
    L_acc = L_mult(tmp, gcode0);             /* Q[exp_gcode0+12+1] */
    L_acc = L_shl(L_acc, add( negate(exp_gcode0),(-12-1+1+16) ));
    *gain_cod = extract_h( L_acc );                          /* Q1 */
    /*----------------------------------------------*
    * update table of past quantized energies      *
    *----------------------------------------------*/
    Gain_update( past_qua_en, L_gbk12 );
	return;
}


/*
   ITU-T G.729A Speech Coder    ANSI-C Source Code
   Version 1.1    Last modified: September 1996

   Copyright (c) 1996,
   AT&T, France Telecom, NTT, Universite de Sherbrooke
   All rights reserved.
*/

/*------------------------------------------------------------------------*
 *    Function Dec_lag3                                                   *
 *             ~~~~~~~~                                                   *
 *   Decoding of fractional pitch lag with 1/3 resolution.                *
 * See "Enc_lag3.c" for more details about the encoding procedure.        *
 *------------------------------------------------------------------------*/



void Dec_lag3(
  short index,       /* input : received pitch index           */
  short pit_min,     /* input : minimum pitch lag              */
  short pit_max,     /* input : maximum pitch lag              */
  short i_subfr,     /* input : subframe short                  */
  short *T0,         /* output: integer part of pitch lag      */
  short *T0_frac     /* output: fractional part of pitch lag   */
)
{
  short i;
  short T0_min, T0_max;

  if (i_subfr == 0)                  /* if 1st subframe */
  {
    if (sub(index, 197) < 0)
    {
      /* *T0 = (index+2)/3 + 19 */

      *T0 = add(mult(add(index, 2), 10923), 19);

      /* *T0_frac = index - *T0*3 + 58 */

      i = add(add(*T0, *T0), *T0);
      *T0_frac = add(sub(index, i), 58);
    }
    else
    {
      *T0 = sub(index, 112);
      *T0_frac = 0;
    }

  }

  else  /* second subframe */
  {
    /* find T0_min and T0_max for 2nd subframe */

    T0_min = sub(*T0, 5);
    if (sub(T0_min, pit_min) < 0)
    {
      T0_min = pit_min;
    }

    T0_max = add(T0_min, 9);
    if (sub(T0_max, pit_max) > 0)
    {
      T0_max = pit_max;
      T0_min = sub(T0_max, 9);
    }

    /* i = (index+2)/3 - 1 */
    /* *T0 = i + t0_min;    */

    i = sub(mult(add(index, 2), 10923), 1);
    *T0 = add(i, T0_min);

    /* t0_frac = index - 2 - i*3; */

    i = add(add(i, i), i);
    *T0_frac = sub(sub(index, 2), i);
  }

  return;
}





/*----------------------------------------------------------------------------
 * prm2bits_ld8k -converts encoder parameter vector into vector of serial bits
 * bits2prm_ld8k - converts serial received bits to  encoder parameter vector
 *
 * The transmitted parameters are:
 *
 *     LPC:     1st codebook           7+1 bit
 *              2nd codebook           5+5 bit
 *
 *     1st subframe:
 *          pitch period                 8 bit
 *          parity check on 1st period   1 bit
 *          codebook index1 (positions) 13 bit
 *          codebook index2 (signs)      4 bit
 *          pitch and codebook gains   4+3 bit
 *
 *     2nd subframe:
 *          pitch period (relative)      5 bit
 *          codebook index1 (positions) 13 bit
 *          codebook index2 (signs)      4 bit
 *          pitch and codebook gains   4+3 bit
 *----------------------------------------------------------------------------
 */
void prm2bits_ld8k( short   prm[],   short bits[] )
{
	short i;
	*bits++ = SYNC_WORD;
	*bits++ = SIZE_WORD;
	
	for (i = 0; i < PRM_SIZE; i++)
	{
        int2bin(prm[i], bitsno[i], bits);  
        bits += bitsno[i];
	}
	return;
}

/*----------------------------------------------------------------------------
 * int2bin convert integer to binary and write the bits bitstream array
 *----------------------------------------------------------------------------
 */
static void int2bin( short value,  short no_of_bits, short *bitstream )
{
	short *pt_bitstream;
	short   i, bit;
	
	pt_bitstream = bitstream + no_of_bits;
	for (i = 0; i < no_of_bits; i++)
	{
		bit = value & (short)0x0001;      /* get lsb */
		if (bit == 0)
			*--pt_bitstream = BIT_0;
		else
			*--pt_bitstream = BIT_1;
		value >>= 1;
	}
}

/// bits2prm_ld8k - converts serial received bits to  encoder parameter vector 
void bits2prm_ld8k( short bits[],  short   prm[] )
{
	short i;
	for (i = 0; i < PRM_SIZE; i++)
	{
        prm[i] = bin2int(bitsno[i], bits); //printf("aaaa==%d\n",bitsno[i]);
        bits  += bitsno[i];
	}
}

///  bin2int - read specified bits from bit array  and convert to integer value 
static short bin2int(  short no_of_bits,  short *bitstream  )
{
	short   value, i;
	short   bit;
	value = 0;
	for (i = 0; i < no_of_bits; i++)
	{
		value <<= 1;
		bit = *bitstream++;
		if (bit == BIT_1)  value += 1;
	}
	return(value);
}









//short Overflow =0;
//short Carry =0;




/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : sature                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    Limit the 32 bit input to the range of a 16 bit word.                  |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short sature(int L_var1)
  {
   short var_out;

   if (L_var1 > 0X00007fffL)
     {
      Overflow = 1;
      var_out = MAX_16;
     }
   else if (L_var1 < (int)0xffff8000L)
     {
      Overflow = 1;
      var_out = MIN_16;
     }
   else
     {
      Overflow = 0;
      var_out = extract_l(L_var1);
     }

   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : add                                                     |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    Performs the addition (var1+var2) with overflow control and saturation;|
 |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
 |    when underflow occurs.                                                 |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short add(short var1,short var2)
  {
   short var_out;
   int L_somme;

   L_somme = (int) var1 + var2;
   var_out = sature(L_somme);
   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : sub                                                     |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    Performs the subtraction (var1+var2) with overflow control and satu-   |
 |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
 |    -32768 when underflow occurs.                                          |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short sub(short var1,short var2)
  {
   short var_out;
   int L_diff;

   L_diff = (int) var1 - var2;
   var_out = sature(L_diff);
   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : abs_s                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    Absolute value of var1; abs_s(-32768) = 32767.                         |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short abs_s(short var1)
  {
   short var_out;

   if (var1 == (short)0X8000 )
     {
      var_out = MAX_16;
     }
   else
     {
      if (var1 < 0)
        {
         var_out = -var1;
        }
      else
        {
         var_out = var1;
        }
      }
    return(var_out);
  }

/*___________________________________________________________________________ 
 |   Function Name : shl                                                     | 
 |   Purpose :                                                               |
  |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
 |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
 |   var1 right by -var2 with sign extension. Saturate the result in case of |
 |   underflows or overflows.                                                |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short shl(short var1,short var2)
  {
   short var_out;
   int resultat;

   //printf("%08x %08x ",var1,var2);
   if (var2 < 0)
     {
	   var2 = -var2;
      var_out = shr(var1,var2);
     }
   else
     {
      resultat = (int) var1 * ((int) 1 << var2);
     if ((var2 > 15 && var1 != 0) || (resultat != (int)((short) resultat)))
        {
         Overflow = 1;
         var_out = (var1 > 0) ? MAX_16 : MIN_16;
        }
      else
        {
         var_out = extract_l(resultat);
        }
     }
   //printf("%08x %08x %08x\n",var1,var2,var_out);getch();
   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : shr                                                     |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
 |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
 |   -var2 with sign extension. Saturate the result in case of underflows or |
 |   overflows.                                                              |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short shr(short var1,short var2)
  {
   short var_out;

   if (var2 < 0)
     {
	   var2=-var2;
	   var_out = shl(var1, var2);
     }
   else
     {
      if (var2 >= 15)
        {
         var_out = (var1 < 0) ? (short)(-1) : (short)0;
        }
      else
        {
         if (var1 < 0)
           {
     var_out = ~(( ~var1) >> var2 );
           }
         else
           {
            var_out = var1 >> var2;
           }
        }
     }

   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : mult                                                    |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
 |    which is scaled i.e.:                                                  |
 |             mult(var1,var2) = shr((var1 times var2),15) and               |
 |             mult(-32768,-32768) = 32767.                                  |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short mult(short var1, short var2)
  {
   short var_out;
   int L_produit;

   L_produit = (int)var1 * (int)var2;

   L_produit = (L_produit & (int) 0xffff8000L) >> 15;

   if (L_produit & (int) 0x00010000L)
     L_produit = L_produit | (int) 0xffff0000L;

   var_out = sature(L_produit);
   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_mult                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
 |   with one shift left i.e.:                                               |
 |        L_mult(var1,var2) = shl((var1 times var2),1) and                   |
 |        L_mult(-32768,-32768) = 2147483647.                                |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_mult(short var1,short var2)
  {
   int L_var_out;

   L_var_out = (int)var1 * (int)var2;
   if (L_var_out != (int)0x40000000L)
     {
      L_var_out *= 2;
     }
   else
     {
      Overflow = 1;
      L_var_out = MAX_32;
     }

   return(L_var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : negate                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Negate var1 with saturation, saturate in the case where input is -32768:|
 |                negate(var1) = sub(0,var1).                                |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short negate(short var1)
  {
   short var_out;

   var_out = (var1 == MIN_16) ? MAX_16 : -var1;
   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : extract_h                                               |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Return the 16 MSB of L_var1.                                            |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int ) whose value falls in the |
 |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short extract_h(int L_var1)
  {
   short var_out;

   var_out = (short) (L_var1 >> 16);
   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : extract_l                                               |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Return the 16 LSB of L_var1.                                            |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int ) whose value falls in the |
 |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short extract_l(int L_var1)
  {
   short var_out;

   var_out = (short) L_var1;
   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : round                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Round the lower 16 bits of the 32 bit input number into its MS 16 bits  |
 |   with saturation. Shift the resulting bits right by 16 and return the 16 |
 |   bit number:                                                             |
 |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int ) whose value falls in the |
 |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short round(int L_var1)
  {
   short var_out;
   int L_arrondi;

   L_arrondi = L_add(L_var1, (int)0x00008000);
   var_out = extract_h(L_arrondi);
   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_mac                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
 |   result to L_var3 with saturation, return a 32 bit result:               |
 |        L_mac(L_var3,var1,var2) = L_add(L_var3,(L_mult(var1,var2)).        |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var3   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_mac(int L_var3, short var1, short var2)
  {
   int L_var_out;
   int L_produit;

   L_produit = L_mult(var1,var2);
   L_var_out = L_add(L_var3,L_produit);
   return(L_var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_msu                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
 |   bit result to L_var3 with saturation, return a 32 bit result:           |
 |        L_msu(L_var3,var1,var2) = L_sub(L_var3,(L_mult(var1,var2)).        |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var3   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_msu(int L_var3, short var1, short var2)
  {
   int L_var_out;
   int L_produit;

   L_produit = L_mult(var1,var2);
   L_var_out = L_sub(L_var3,L_produit);
   return(L_var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_macNs                                                 |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
 |   result to L_var3 without saturation, return a 32 bit result. Generate   |
 |   carry and overflow values :                                             |
 |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,(L_mult(var1,var2)).    |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var3   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |                                                                           |
 |   Caution :                                                               |
 |                                                                           |
 |    In some cases the Carry short has to be cleared or set before using op- |
 |    rators which take into account its value.                              |
 |___________________________________________________________________________|
*/

int L_macNs(int L_var3, short var1, short var2)
  {
   int L_var_out;

   L_var_out = L_mult(var1,var2);
   L_var_out = L_add_c(L_var3,L_var_out);
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_msuNs                                                 |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
 |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
 |   nerate carry and overflow values :                                      |
 |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,(L_mult(var1,var2)).    |
 |                                                                           |
 |   Complexity weight : 1                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var3   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |                                                                           |
 |   Caution :                                                               |
 |                                                                           |
 |    In some cases the Carry short has to be cleared or set before using op- |
 |    rators which take into account its value.                              |
 |___________________________________________________________________________|
*/

int L_msuNs(int L_var3, short var1, short var2)
  {
   int L_var_out;

   L_var_out = L_mult(var1,var2);
   L_var_out = L_sub_c(L_var3,L_var_out);
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_add                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
 |   overflow control and saturation; the result is set at +214783647 when   |
 |   overflow occurs or at -214783648 when underflow occurs.                 |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    L_var2   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_add(int L_var1, int L_var2)
  {
   int L_var_out;

   L_var_out = L_var1 + L_var2;

   if (((L_var1 ^ L_var2) & MIN_32) == 0)
     {
      if ((L_var_out ^ L_var1) & MIN_32)
        {
         L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
         Overflow = 1;
        }
     }
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_sub                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
 |   overflow control and saturation; the result is set at +214783647 when   |
 |   overflow occurs or at -214783648 when underflow occurs.                 |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    L_var2   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_sub(int L_var1, int L_var2)
  {
   int L_var_out;

   L_var_out = L_var1 - L_var2;

   if (((L_var1 ^ L_var2) & MIN_32) != 0)
     {
      if ((L_var_out ^ L_var1) & MIN_32)
        {
         L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
         Overflow = 1;
        }
     }
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_add_c                                                 |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
 |   with carry. No saturation. Generate carry and Overflow values. The car- |
 |   ry and overflow values are binary variables which can be tested and as- |
 |   signed values.                                                          |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    L_var2   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |                                                                           |
 |   Caution :                                                               |
 |                                                                           |
 |    In some cases the Carry short has to be cleared or set before using op- |
 |    rators which take into account its value.                              |
 |___________________________________________________________________________|
*/
int L_add_c(int L_var1, int L_var2)
  {
   int L_var_out;
   int L_test;
   short carry_int = 0;

   L_var_out = L_var1 + L_var2 + Carry;

   L_test = L_var1 + L_var2;

   if ((L_var1>0) && (L_var2 >0) && (L_test < 0))
     {
      Overflow = 1;
      carry_int = 0;
     }
   else
     {
      if ((L_var1<0) && (L_var2 <0) && (L_test >0))
        {
         Overflow = 1;
         carry_int = 1;
        }
      else
        {
         if (((L_var1 ^ L_var2) < 0) && (L_test > 0))
           {
            Overflow = 0;
            carry_int = 1;
           }
         else
           {
            Overflow = 0;
            carry_int = 0;
           }
        }
     }

   if (Carry)
     {
      if (L_test == MAX_32)
        {
         Overflow = 1;
         Carry = carry_int;
        }
      else
        {
         if (L_test == (int) 0xFFFFFFFFL)
           {
            Carry = 1;
           }
         else
           {
            Carry = carry_int;
           }
        }
     }
   else
     {
      Carry = carry_int;
     }

   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_sub_c                                                 |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
 |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
 |   values. The carry and overflow values are binary variables which can    |
 |   be tested and assigned values.                                          |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    L_var2   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |                                                                           |
 |   Caution :                                                               |
 |                                                                           |
 |    In some cases the Carry short has to be cleared or set before using op- |
 |    rators which take into account its value.                              |
 |___________________________________________________________________________|
*/

int L_sub_c(int L_var1, int L_var2)
  {
   int L_var_out;
   int L_test;
   short carry_int = 0;

   if (Carry)
     {
      Carry = 0;
      if (L_var2 != MIN_32)
        {
         L_var_out = L_add_c(L_var1,-L_var2);
        }
      else
        {
         L_var_out = L_var1 - L_var2;
         if (L_var1 > 0L)
           {
            Overflow = 1;
            Carry = 0;
           }
        }
     }
   else
     {
      L_var_out = L_var1 - L_var2 - (int)0X00000001;
      L_test = L_var1 - L_var2;

      if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
        {
         Overflow = 1;
         carry_int = 0;
        }
      else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
        {
         Overflow = 1;
         carry_int = 1;
        }
      else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
        {
         Overflow = 0;
         carry_int = 1;
        }


      if (L_test == MIN_32)
        {
         Overflow = 1;
         Carry = carry_int;
        }
      else
        {
         Carry = carry_int;
        }
     }

   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_negate                                                |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
 |   where input is -2147483648 (0x8000 0000).                               |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_negate(int L_var1)
  {
   int L_var_out;

   L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : mult_r                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Same as mult with rounding, i.e.:                                       |
 |     mult_r(var1,var2) = shr(((var1*var2) + 16384),15) and                 |
 |     mult_r(-32768,-32768) = 32767.                                        |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short mult_r(short var1, short var2)
  {
   short var_out;
   int L_produit_arr;

   L_produit_arr = (int)var1 * (int)var2; /* product */
   L_produit_arr += (int) 0x00004000;        /* round */
   L_produit_arr &= (int) 0xffff8000L;
   L_produit_arr >>= 15;                        /* shift */

   if (L_produit_arr & (int) 0x00010000L)   /* sign extend when necessary */
     {
      L_produit_arr |= (int) 0xffff0000L;
     }

   var_out = sature(L_produit_arr);
   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_shl                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
 |   fill the var2 LSB of the result. If var2 is negative, L_var1 right by   |
 |   -var2 arithmetically shift with sign extension. Saturate the result in  |
 |   case of underflows or overflows.                                        |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_shl(int L_var1, short var2)
{
   int L_var_out;

   /* initialization used only to suppress Microsoft Visual C++ warnings */
   L_var_out = 0L;

   if (var2 <= 0)
     {
	   var2=-var2;
	   L_var_out = L_shr(L_var1,var2);
     }
   else
     {
      for(;var2>0;var2--)
        {
         if (L_var1 > (int) 0X3fffffffL)
           {
            Overflow = 1;
            L_var_out = MAX_32;
            break;
           }
         else
           {
            if (L_var1 < (int) 0xc0000000L)
              {
               Overflow = 1;
               L_var_out = MIN_32;
               break;
              }
           }
         L_var1 *= 2;
         L_var_out = L_var1;
        }
     }
   return(L_var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_shr                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
 |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
 |   by -var2 and zero fill the var2 LSB of the result. Saturate the result  |
 |   in case of underflows or overflows.                                     |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
 |___________________________________________________________________________|
*/

int L_shr(int L_var1, short var2)
  {
   int L_var_out;

   if (var2 < 0)
     {
	   var2=-var2;
      L_var_out = L_shl(L_var1,var2);
     }
   else
     {
      if (var2 >= 31)
        {
         L_var_out = (L_var1 < 0L) ? -1 : 0;
        }
      else
        {
         if (L_var1<0)
           {
            L_var_out = ~((~L_var1) >> var2);
           }
        else
          {
           L_var_out = L_var1 >> var2;
          }
        }
     }
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : shr_r                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
 |   underflows or overflows :                                               |
 |    If var2 is greater than zero :                                         |
 |       shr_r(var1,var2) = shr(add(var1,2**(var2-1)),var2)                  |
 |    If var2 is less than zero :                                            |
 |       shr_r(var1,var2) = shr(var1,var2).                                  |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

short shr_r(short var1, short var2)
  {
   short var_out;

   if (var2>15)
     {
      var_out = 0;
     }
   else
     {
      var_out = shr(var1,var2);

      if (var2 > 0)
        {
         if ((var1 & ((short)1 << (var2-1))) != 0)
           {
            var_out++;
           }
        }
     }
   return(var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : mac_r                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
 |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
 |   into the MS 16 bits with saturation and shift the result right by 16.   |
 |   Return a 16 bit result.                                                 |
 |            mac_r(L_var3,var1,var2) = round(L_mac(Lvar3,var1,var2))        |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var3   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
 |___________________________________________________________________________|
*/

short mac_r(int L_var3, short var1, short var2)
  {
   short var_out;

   L_var3 = L_mac(L_var3,var1,var2);
   L_var3 = L_add(L_var3, (int) 0x00008000);
   var_out = extract_h(L_var3);
   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : msu_r                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
 |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
 |   ult into the MS 16 bits with saturation and shift the result right by   |
 |   16. Return a 16 bit result.                                             |
 |            msu_r(L_var3,var1,var2) = round(L_msu(Lvar3,var1,var2))        |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var3   32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
 |___________________________________________________________________________|
*/

short msu_r(int L_var3, short var1, short var2)
  {
   short var_out;

   L_var3 = L_msu(L_var3,var1,var2);
   L_var3 = L_add(L_var3, (int) 0x00008000);
   var_out = extract_h(L_var3);
   return(var_out);
  }



/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_deposit_h                                             |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
 |   16 LS bits of the output are zeroed.                                    |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
 |___________________________________________________________________________|
*/

int L_deposit_h(short var1)
  {
   int L_var_out;

   L_var_out = (int) var1 << 16;
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_deposit_l                                             |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
 |   16 MS bits of the output are sign extended.                             |
 |                                                                           |
 |   Complexity weight : 2                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
 |___________________________________________________________________________|
*/

int L_deposit_l(short var1)
  {
   int L_var_out;

   L_var_out = (int) var1;
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_shr_r                                                 |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Same as L_shr(L_var1,var2)but with rounding. Saturate the result in case|
 |   of underflows or overflows :                                            |
 |    If var2 is greater than zero :                                         |
 |       L_shr_r(var1,var2) = L_shr(L_add(L_var1,2**(var2-1)),var2)          |
 |    If var2 is less than zero :                                            |
 |       L_shr_r(var1,var2) = L_shr(L_var1,var2).                            |
 |                                                                           |
 |   Complexity weight : 3                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
 |___________________________________________________________________________|
*/

int L_shr_r(int L_var1,short var2)
  {
   int L_var_out;

   if (var2 > 31)
     {
      L_var_out = 0;
     }
   else
     {
      L_var_out = L_shr(L_var1,var2);
      if (var2 > 0)
        {
         if ( (L_var1 & ( (int)1 << (var2-1) )) != 0)
           {
            L_var_out++;
           }
        }
     }
   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_abs                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    Absolute value of L_var1; Saturate in case where the input is          |
 |                                                               -214783648  |
 |                                                                           |
 |   Complexity weight : 3                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x0000 0000 <= var_out <= 0x7fff ffff.                |
 |___________________________________________________________________________|
*/

int L_abs(int L_var1)
  {
   int L_var_out;

   if (L_var1 == MIN_32)
     {
      L_var_out = MAX_32;
     }
   else
     {
      if (L_var1 < 0)
        {
         L_var_out = -L_var1;
        }
      else
        {
         L_var_out = L_var1;
        }
     }

   return(L_var_out);
  }

/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : L_sat                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |    32 bit L_var1 is set to 2147833647 if an overflow occurred or to       |
 |    -214783648 if an underflow occurred on the most recent L_add_c, L_sub_c|
 |    L_macNs or LmsuNs operations. The carry and overflow values are binary |
 |    values which can be tested and assigned values.                        |
 |                                                                           |
 |   Complexity weight : 4                                                   |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    L_var_out                                                              |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
 |___________________________________________________________________________|
*/

int L_sat (int L_var1)
  {
   int L_var_out;


   L_var_out = L_var1;

   if (Overflow)
     {

      if (Carry)
        {
         L_var_out = MIN_32;
        }
      else
        {
         L_var_out = MAX_32;
        }

      Carry = 0;
      Overflow = 0;
     }

   return(L_var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : norm_s                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Produces the number of left shift needed to normalize the 16 bit varia- |
 |   ble var1 for positive values on the interval with minimum of 16384 and  |
 |   maximum of 32767, and for negative values on the interval with minimum  |
 |   of -32768 and maximum of -16384; in order to normalize the result, the  |
 |   following operation must be done :                                      |
 |                    norm_var1 = shl(var1,norm_s(var1)).                    |
 |                                                                           |
 |   Complexity weight : 15                                                  |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 0000 <= var_out <= 0x0000 000f.                |
 |___________________________________________________________________________|
*/

short norm_s(short var1)
  {
   short var_out;

   if (var1 == 0)
     {
      var_out = 0;
     }
   else
     {
      if (var1 == (short) 0xffff)
        {
         var_out = 15;
        }
      else
        {
         if (var1 < 0)
           {
            var1 = ~var1;
           }

         for(var_out = 0; var1 < 0x4000; var_out++)
           {
            var1 <<= 1;
           }
        }
     }

   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : div_s                                                   |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Produces a result which is the fractional  integer division of var1 by  |
 |   var2; var1 and var2 must be positive and var2 must be greater or equal  |
 |   to var1; the result is positive (leading bit equal to 0) and truncated  |
 |   to 16 bits.                                                             |
 |   If var1 = var2 then div(var1,var2) = 32767.                             |
 |                                                                           |
 |   Complexity weight : 18                                                  |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    var1                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 0000 <= var1 <= var2 and var2 != 0.            |
 |                                                                           |
 |    var2                                                                   |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : var1 <= var2 <= 0x0000 7fff and var2 != 0.            |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
 |             It's a Q15 value (point between b15 and b14).                 |
 |___________________________________________________________________________|
*/

short div_s(short var1, short var2)
  {
   short var_out = 0;
   short iteration;
   int L_num;
   int L_denom;

   if ((var1 > var2) || (var1 < 0) || (var2 < 0))
     {
      printf("Division Error var1=%d  var2=%d\n",var1,var2);
      exit(0);
     }

   if (var2 == 0)
     {
      printf("Division by 0, Fatal error \n");
      exit(0);
     }

   if (var1 == 0)
     {
      var_out = 0;
     }
   else
     {
      if (var1 == var2)
        {
         var_out = MAX_16;
        }
      else
        {
         L_num = L_deposit_l(var1);
         L_denom = L_deposit_l(var2);

         for(iteration=0;iteration<15;iteration++)
           {
            var_out <<=1;
            L_num <<= 1;

            if (L_num >= L_denom)
              {
               L_num = L_sub(L_num,L_denom);
               var_out = add(var_out,1);
              }
           }
        }
     }

   return(var_out);
  }


/*___________________________________________________________________________
 |                                                                           |
 |   Function Name : norm_l                                                  |
 |                                                                           |
 |   Purpose :                                                               |
 |                                                                           |
 |   Produces the number of left shift needed to normalize the 32 bit varia- |
 |   ble l_var1 for positive values on the interval with minimum of          |
 |   1073741824 and maximum of 2147483647, and for negative values on the in-|
 |   terval with minimum of -2147483648 and maximum of -1073741824; in order |
 |   to normalize the result, the following operation must be done :         |
 |                   norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).             |
 |                                                                           |
 |   Complexity weight : 30                                                  |
 |                                                                           |
 |   Inputs :                                                                |
 |                                                                           |
 |    L_var1                                                                 |
 |             32 bit long signed integer (int) whose value falls in the  |
 |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
 |                                                                           |
 |   Outputs :                                                               |
 |                                                                           |
 |    none                                                                   |
 |                                                                           |
 |   Return Value :                                                          |
 |                                                                           |
 |    var_out                                                                |
 |             16 bit short signed integer (short) whose value falls in the |
 |             range : 0x0000 0000 <= var_out <= 0x0000 001f.                |
 |___________________________________________________________________________|
*/

short norm_l(int L_var1)
  {
   short var_out;

   if (L_var1 == 0)
     {
      var_out = 0;
     }
   else
     {
      if (L_var1 == (int)0xffffffffL)
        {
         var_out = 31;
        }
      else
        {
         if (L_var1 < 0)
           {
            L_var1 = ~L_var1;
           }

         for(var_out = 0;L_var1 < (int)0x40000000L;var_out++)
           {
            L_var1 <<= 1;
           }
        }
     }

   return(var_out);
  }

short bad_lsf;

int g729a_decode(unsigned char in[], int inlen, unsigned char out[])
{
	short  synth_buf[L_FRAME+M],*synth, parm[PRM_SIZE+1], serial[SERIAL_SIZE], Az_dec[MP1*2], T2[2];	
	int i,j,k;	
	unsigned char sd[200];
	unsigned char AU_header[24] = {'.','s','n','d',0,0,0,0x18,0xff,0xff,0xff,0xff,0,0,0,0x03,0,0,0x1f,0x40,0,0,0,0x01}; 
	for(i=0;i<24;i++)out[i]=AU_header[i];
    
	for (i=0; i<M; i++) synth_buf[i] = 0;   synth = synth_buf + M; 	bad_lsf = 0;   
	Init_Decod_ld8a();   Init_Post_Filter();   Init_Post_Process();	
	for(k=0;k<inlen;k+=10)
	{
		 sd[0]=0x21;sd[1]=0x6b;sd[2]=0x50;sd[3]=0x00;
		 for(i=0;i<10;i++)for(j=0;j<8;j++)if((in[i+k]>>(7-j)&1)==1){sd[4+(i*8+j)*2]=0x81;sd[4+(i*8+j)*2+1]=0;}else {sd[4+(i*8+j)*2]=0x7f;sd[4+(i*8+j)*2+1]=0;}			 
		 for(i=0;i<82;i++)serial[i]=(sd[i*2]<<0)+(sd[i*2+1]<<8);		 
		 bits2prm_ld8k( &serial[2], &parm[1]);  parm[0] = 0;           
		 for (i=2; i < SERIAL_SIZE; i++)if (serial[i] == 0 ) parm[0] = 1;
		 parm[4] = Check_Parity_Pitch(parm[3], parm[4]);
		 Decod_ld8a(parm, synth, Az_dec, T2);	  Post_Filter(synth, Az_dec, T2);  	  Post_Process(synth, L_FRAME);
		 for(i=0;i<80;i++){out[i*2+k*16+24]=synth[i]>>8&0xff; out[i*2+k*16+24+1]=synth[i]>>0&0xff; }
	}    
	return inlen*16+24;
}